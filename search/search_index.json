{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started with Linux","text":"<p>GNU/Linux, often referred to as simply Linux, is a powerful and versatile operating system that has gained widespread popularity and adoption around the world. Unlike other operating systems, GNU/Linux is built upon the principles of open-source software, which means that its source code is freely available to the public, allowing anyone to view, modify, and distribute it.</p> <p>The origins of GNU/Linux trace back to the early 1980s when the renowned computer scientist Richard Stallman launched the GNU Project. Stallman's vision was to create a complete, free, and open-source operating system. Over time, numerous developers and enthusiasts joined forces, contributing their expertise to build a robust software ecosystem.</p> <p>At the heart of GNU/Linux lies the Linux kernel, created by Linus Torvalds in 1991. The Linux kernel forms the core of the operating system, handling essential tasks such as hardware management, process scheduling, and resource allocation. Together with the GNU Project's collection of utilities, compilers, and libraries, Linux provides a solid foundation for a wide range of computing systems.</p> <p>One of the defining features of GNU/Linux is its flexibility. It can be tailored to suit various needs and preferences, from desktop computers and servers to embedded devices and supercomputers. This adaptability, combined with the vast array of available software, makes GNU/Linux a preferred choice for both individuals and organizations seeking stability, security, and customization options.</p> <p>GNU/Linux distributions, or distros, are complete operating systems built on top of the Linux kernel and the GNU tools. They come in different flavors, each with its own set of pre-installed applications, package managers, and user interfaces. Popular distros like Ubuntu, Debian, Fedora, and CentOS have contributed to the widespread adoption of GNU/Linux by providing user-friendly environments and extensive software repositories.</p> <p>In addition to its technical merits, GNU/Linux embodies the principles of freedom, collaboration, and community-driven development. It fosters a culture of sharing knowledge and empowering users to take control of their computing experiences. This vibrant ecosystem thrives on the contributions of countless developers, translators, artists, and enthusiasts who work together to improve the system and make it accessible to all.</p> <p>With its rich history, open nature, and exceptional versatility, GNU/Linux has become an integral part of the modern computing landscape, empowering users to explore, create, and innovate in ways that were once unimaginable. Whether you are a developer, student, researcher, or simply someone who appreciates the power of choice and customization, GNU/Linux offers a compelling platform for your digital journey.</p>"},{"location":"baseline/","title":"Index","text":"<p>I use Pop!_OS which is based off Ubuntu so this section will be mostly around this distro. You should be able to follow this on most any distro with minor tweaking.</p> <p>The Baseline section will allow you to et started with Linux including things like setting up your SSH keys, getting brew installed, installing Ruby and some other tidbits.</p>"},{"location":"baseline/dev/apis/","title":"APIs","text":""},{"location":"baseline/dev/apis/#talking-to-services-introduction-to-apis","title":"Talking to Services: Introduction to APIs","text":"<p>In modern software development, applications rarely exist in isolation. They often need to communicate with other software components, databases, or external services. An API (Application Programming Interface) defines the rules and protocols for how these different software entities can interact.</p> <p>Think of an API like a menu in a restaurant:</p> <ul> <li>The menu (API) lists the dishes (functionality/data) you can order.</li> <li>It specifies how to place an order (request format, required parameters).</li> <li>It tells you what you'll get back (response format).</li> <li>You don't need to know how the kitchen (the underlying system) prepares the dish, just how to order it using the menu.</li> </ul>"},{"location":"baseline/dev/apis/#why-use-apis","title":"Why Use APIs?","text":"<ul> <li>Modularity: Break down complex systems into smaller, independent components that communicate via well-defined interfaces.</li> <li>Reusability: Allow functionality or data provided by one system to be used by many others without duplicating code.</li> <li>Integration: Connect disparate systems, services, and platforms (e.g., connecting your web app to a payment gateway, a social media service, or a weather service).</li> <li>Abstraction: Hide the internal complexity of a system, exposing only the necessary functionality.</li> </ul>"},{"location":"baseline/dev/apis/#common-types-of-apis","title":"Common Types of APIs","text":"<p>While APIs exist in many forms, developers often interact with these types:</p> <ul> <li>Web APIs (HTTP-based): These are accessed over the web using the HTTP protocol. They are the foundation of interaction between web servers, front-end applications, mobile apps, and third-party services.<ul> <li>REST (Representational State Transfer): Not a strict protocol, but an architectural style that's extremely popular. Key characteristics:<ul> <li>Uses standard HTTP methods (verbs): <code>GET</code> (retrieve data), <code>POST</code> (create data), <code>PUT</code> (update data), <code>DELETE</code> (remove data).</li> <li>Operates on Resources (e.g., <code>/users</code>, <code>/products/123</code>).</li> <li>Typically uses JSON (JavaScript Object Notation) as the data format.</li> <li>Stateless (each request contains all info needed; server doesn't store client state between requests).</li> </ul> </li> <li>SOAP (Simple Object Access Protocol): An older, stricter protocol based on XML. Less common now for new public web APIs but still used in some enterprise environments.</li> <li>GraphQL: A query language for APIs. Allows the client to request exactly the data fields it needs in a single request, preventing over-fetching or under-fetching of data common with REST. Developed by Facebook.</li> </ul> </li> <li>Library/Framework APIs: These are the interfaces provided by the code libraries or frameworks you use in your project. For example, when you use Python's <code>requests</code> library to make an HTTP call (<code>requests.get(...)</code>), you are using its API. When you use functions from your operating system or a graphics library, you're using their APIs.</li> <li>Operating System APIs: Low-level interfaces provided by the OS for interacting with hardware, managing processes, accessing the file system, etc. (e.g., POSIX API on Unix-like systems, Windows API).</li> </ul>"},{"location":"baseline/dev/apis/#interacting-with-web-apis","title":"Interacting with Web APIs","text":"<p>Developers most frequently interact with Web APIs (especially REST APIs). Here's how:</p> <ul> <li>Making HTTP Requests: You need to send an HTTP request to a specific URL (the endpoint). The request includes:<ul> <li>Method: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc.</li> <li>URL/Endpoint: The address of the resource you want to interact with.</li> <li>Headers: Metadata about the request (e.g., <code>Content-Type: application/json</code>, <code>Authorization</code>).</li> <li>Body: Data sent with the request (used with <code>POST</code>, <code>PUT</code>), often in JSON format.</li> </ul> </li> <li>Handling HTTP Responses: The server sends back an HTTP response, including:<ul> <li>Status Code: Indicates success or failure (e.g., <code>200 OK</code>, <code>201 Created</code>, <code>404 Not Found</code>, <code>401 Unauthorized</code>, <code>500 Internal Server Error</code>).</li> <li>Headers: Metadata about the response.</li> <li>Body: The requested data (for <code>GET</code>) or confirmation/error details, often in JSON.</li> </ul> </li> <li>Tools for Interaction:<ul> <li>Command Line: <code>curl</code>, <code>wget</code>.</li> <li>GUI Tools: Postman, Insomnia (excellent for testing and exploring APIs).</li> <li>Programming Libraries: Python (<code>requests</code>), JavaScript (<code>fetch</code> API, <code>axios</code>), Java (<code>HttpClient</code>, <code>OkHttp</code>), etc.</li> </ul> </li> <li>Authentication: APIs often require authentication to identify the client and ensure they have permission. Common methods include API Keys (sent in headers or query parameters) and OAuth (a more complex but standard protocol for delegated authorization).</li> </ul> <p>APIs are the glue that holds modern software systems together. Understanding how to find, read documentation for, and interact with APIs (especially web APIs like REST) is a fundamental skill for developers building connected applications and services.</p>"},{"location":"baseline/dev/build_tools/","title":"Automating the Build: Introduction to Build Tools","text":"<p>As projects grow beyond a few files, manually compiling, testing, and packaging becomes tedious and error-prone. Build tools automate these repetitive tasks, ensuring consistency and improving developer productivity.</p>"},{"location":"baseline/dev/build_tools/#why-use-build-tools","title":"Why Use Build Tools?","text":"<p>Imagine a C project with dozens of source files, external libraries, and specific compilation flags. Compiling everything manually with <code>gcc</code> commands would be a nightmare. Build tools handle this complexity. They automate tasks like:</p> <ul> <li>Dependency Management: Automatically downloading and managing the external libraries (dependencies) your project relies on.</li> <li>Compilation: Translating source code (e.g., .java, .c) into executable code (e.g., .class, object files).</li> <li>Linking: Combining compiled code and libraries into a final executable or library.</li> <li>Testing: Running automated unit tests, integration tests, etc.</li> <li>Packaging: Creating distributable artifacts like JAR files, Python wheels, Docker images, or zipped archives.</li> <li>Code Generation: Generating source code automatically based on definitions (less common, but powerful).</li> <li>Deployment: Pushing the final application to servers or artifact repositories.</li> </ul>"},{"location":"baseline/dev/build_tools/#how-they-work-configuration-over-commands","title":"How They Work: Configuration over Commands","text":"<p>Instead of writing complex shell scripts, you typically define the build process in a configuration file specific to the tool. The build tool reads this file and executes the necessary steps in the correct order.</p>"},{"location":"baseline/dev/build_tools/#examples-of-build-tools-by-ecosystem","title":"Examples of Build Tools (by Ecosystem)","text":"<p>Different programming ecosystems have their own popular build tools:</p> <ul> <li>C / C++:<ul> <li>Make: A classic, widely used tool. Reads instructions from a <code>Makefile</code>. Can be complex to write Makefiles manually.</li> <li>CMake: A cross-platform build system generator. It generates native build files (like Makefiles or Visual Studio projects) from a <code>CMakeLists.txt</code> configuration. More modern and flexible than Make alone.</li> <li>Autotools: Another older suite (<code>Autoconf</code>, <code>Automake</code>) common in open-source Unix/Linux projects, focused on portability.</li> </ul> </li> <li>Java:<ul> <li>Maven: Uses a declarative approach with XML configuration (<code>pom.xml</code>). Manages dependencies, lifecycle phases (compile, test, package), and plugins effectively. Very established.</li> <li>Gradle: Uses a Groovy or Kotlin DSL (Domain Specific Language) for configuration (<code>build.gradle</code>). Offers more flexibility than Maven, often faster due to caching and incremental builds. Gaining popularity, standard for Android development.</li> </ul> </li> <li>JavaScript / Node.js:<ul> <li>npm (Node Package Manager): Primarily a package manager, but also acts as a task runner via scripts defined in <code>package.json</code>.</li> <li>Yarn: An alternative package manager, often faster and more deterministic than older npm versions. Also runs scripts.</li> <li>Webpack / Parcel / Rollup: Module bundlers, primarily for front-end development. They bundle JavaScript modules, CSS, images, etc., into optimized assets for browsers.</li> <li>Gulp / Grunt: Task runners for automating arbitrary development tasks (minification, image optimization, etc.). Less common now for bundling compared to <code>Webpack</code>/<code>Parcel</code>.</li> </ul> </li> <li>Python:<ul> <li>pip: The standard package installer/manager (manages dependencies listed in <code>requirements.txt</code> or <code>pyproject.toml</code>).</li> <li>setuptools / build: Libraries used for defining how to build and package Python projects (creating wheels and source distributions), configured via <code>pyproject.toml</code> (preferred) or setup.py.</li> <li>Tox / Nox: Tools for automating testing across different Python versions and environments.</li> <li>Invoke / Make (yes, Make!): General-purpose task runners sometimes used for Python project automation.</li> </ul> </li> </ul> <p>Build tools are indispensable for modern software development. They automate repetitive tasks, manage complex dependencies, ensure consistent builds, and integrate various development stages like testing and packaging. Learning the standard build tool(s) for your chosen language/ecosystem is a crucial step towards professional development.</p>"},{"location":"baseline/dev/debug/","title":"Finding and Fixing Bugs: An Introduction to Debugging","text":"<p>Writing code inevitably means writing bugs. Debugging is the essential process of finding, analyzing, and fixing these errors or unexpected behaviors in your software. It's a critical skill for any developer.</p>"},{"location":"baseline/dev/debug/#common-types-of-bugs","title":"Common Types of Bugs","text":"<ul> <li>Syntax Errors: Mistakes in the code that violate the programming language's rules (e.g., typos, missing punctuation). These are usually caught by the compiler or interpreter before the program runs.</li> <li>Runtime Errors: Errors that occur while the program is running (e.g., trying to divide by zero, accessing a file that doesn't exist, referencing a null object). These often cause the program to crash.</li> <li>Logical Errors: The code runs without crashing, but it doesn't produce the expected result. The logic of the program is flawed. These are often the hardest bugs to find.</li> </ul>"},{"location":"baseline/dev/debug/#debugging-strategies","title":"Debugging Strategies","text":"<p>Debugging is a systematic process, not guesswork. Here are common strategies:</p> <ul> <li>Understand and Reproduce the Bug:<ul> <li>Clearly identify the incorrect behavior versus the expected behavior.</li> <li>Find a reliable way to make the bug happen consistently. If you can't reproduce it, you can't easily fix it.</li> </ul> </li> <li>Read Error Messages and Stack Traces:<ul> <li>Don't ignore error messages! They often tell you the type of error and the exact line number where it occurred.</li> <li>A stack trace shows the sequence of function calls that led up to the error, helping you trace the execution path.</li> </ul> </li> <li>Print Statement Debugging:<ul> <li>The simplest technique: strategically insert print statements (print(), console.log(), System.out.println(), etc.) in your code to output variable values or messages indicating which parts of the code are being executed.</li> <li>Pros: Simple, works anywhere, requires no special tools.</li> <li>Cons: Clutters code, need to remove statements later, can be tedious for complex problems.</li> </ul> </li> <li>Using a Debugger Tool:<ul> <li>Interactive debuggers are powerful tools (often built into IDEs or available standalone) that let you control program execution and inspect its state. Key features include:<ul> <li>Breakpoints: Set points in your code where execution will pause, allowing you to examine the program's state at that exact moment.</li> <li>Stepping: Execute code one line or function at a time:<ul> <li>Step Over: Execute the current line; if it's a function call, execute the whole function without going inside.</li> <li>Step Into: If the current line is a function call, move execution inside that function.</li> <li>Step Out: If inside a function, continue execution until the function returns.</li> </ul> </li> <li>Inspecting Variables: View the values of variables, objects, and data structures while paused.</li> <li>Call Stack: See the chain of function calls that led to the current point.</li> </ul> </li> </ul> </li> <li>Isolate the Problem:<ul> <li>Comment out sections of code to narrow down where the bug might be occurring.</li> <li>Test individual functions or modules in isolation if possible.</li> </ul> </li> <li>Rubber Duck Debugging:<ul> <li>Explain the problem and your code, line by line, out loud to someone else, or even to an inanimate object (like a rubber duck). The act of verbalizing often helps you spot the flawed logic yourself.</li> </ul> </li> </ul>"},{"location":"baseline/dev/debug/#example-debugger-tools","title":"Example Debugger Tools","text":"<ul> <li>GDB (GNU Debugger): Powerful command-line debugger primarily for C, C++, and other compiled languages.</li> <li>PDB (Python Debugger): Python's built-in command-line debugger.</li> <li>Browser Developer Tools: Modern web browsers (Chrome, Firefox, Edge) have excellent built-in JavaScript debuggers.</li> <li>IDE Debuggers: Most IDEs (PyCharm, IntelliJ, VS Code, Visual Studio) have sophisticated, integrated graphical debuggers.</li> </ul> <p>Debugging is part art, part science. It requires patience, logical thinking, and familiarity with your tools. Don't be discouraged by bugs \u2013 view them as puzzles to be solved. The more you practice, the better and faster you'll become at diagnosing and fixing them.</p>"},{"location":"baseline/dev/dev_index/","title":"Development Tools &amp; Concepts","text":"<p>Writing code is just one part of software development. To build robust, efficient, and maintainable software, especially in a team, you need to master various tools and understand core development concepts. These tools automate tasks, improve code quality, facilitate collaboration, and help you manage complexity.</p> <p>This section explores some essential tools and concepts beyond the basic programming language syntax:</p> <ul> <li>Text Editors and IDEs: Choosing the right environment to write and manage your code.</li> <li>Debugging: The essential skill of finding and fixing errors in your programs.</li> <li>Build Tools &amp; Automation: Automating the process of compiling, testing, packaging, and deploying your software.</li> <li>Introduction to APIs: Understanding how different software components and services communicate with each other.</li> <li>Secure Coding Practices: Building security into your applications from the start.</li> </ul> <p>Understanding these areas will make you a more effective and well-rounded developer. Click the links above to dive into each topic.</p>"},{"location":"baseline/dev/ides/","title":"Choosing Your Weapon: Text Editors and IDEs","text":"<p>Every developer needs a place to write code. The tools you use can significantly impact your productivity and workflow. The two main categories are Text Editors and Integrated Development Environments (IDEs).</p>"},{"location":"baseline/dev/ides/#text-editors","title":"Text Editors","text":"<p>These are generally lightweight applications focused primarily on editing plain text files, including source code.</p> <ul> <li>Definition: Tools designed for efficient text manipulation, often highly customizable through plugins and configurations.</li> <li>Pros:<ul> <li>Fast and lightweight, consume fewer system resources.</li> <li>Highly extensible and configurable.</li> <li>Excellent for scripting, configuration files, or quick edits.</li> <li>Often free and open-source.</li> </ul> </li> <li>Cons:<ul> <li>May require significant setup and plugin installation for advanced features (debugging, code completion, etc.).</li> <li>Can have a steeper learning curve for advanced customization (e.g., Vim, Emacs).</li> </ul> </li> <li>Examples:<ul> <li>Visual Studio Code (VS Code): Free, highly extensible, huge community. Blurs the line between editor and IDE with its vast marketplace of extensions. Very popular.</li> <li>Sublime Text: Fast, proprietary editor known for its \"Goto Anything\" feature and multi-cursor support. Requires a license for continued use, but has an unlimited trial.</li> <li>Vim / Neovim: Powerful, modal text editor built for efficiency, runs in the terminal. Has a steep learning curve but is incredibly productive once mastered.</li> <li>Emacs: Another highly extensible, customizable editor known for its Lisp-based configuration. Often described as an \"operating system\" due to its capabilities.</li> <li>Nano: Simple, beginner-friendly terminal-based editor, good for basic edits on servers.</li> </ul> </li> </ul>"},{"location":"baseline/dev/ides/#integrated-development-environments-ides","title":"Integrated Development Environments (IDEs)","text":"<p>IDEs are comprehensive software suites that bundle multiple development tools into a single application.</p> <ul> <li>Definition: Applications providing a rich set of tools specifically designed for software development, often tailored to specific languages or platforms.</li> <li>Pros:<ul> <li>All-in-one solution: Includes editor, debugger, build tools, version control integration, intelligent code completion, refactoring tools, etc.</li> <li>Powerful debugging capabilities are often built-in.</li> <li>Excellent project management features.</li> <li>Can significantly speed up development for complex projects.</li> </ul> </li> <li>Cons:<ul> <li>Can be resource-intensive (memory, CPU).</li> <li>May feel like overkill for simple scripts or projects.</li> <li>Can be less flexible or customizable than text editors in some ways.</li> <li>Often commercial (though many have free community editions).</li> </ul> </li> <li>Examples:<ul> <li>JetBrains Suite (PyCharm, IntelliJ IDEA, WebStorm, etc.): Industry-leading IDEs known for excellent code intelligence and features. Often language/ecosystem specific (PyCharm for Python, IntelliJ for Java/Kotlin/JVM, WebStorm for JavaScript/Web). Offer free Community editions and paid Professional editions.</li> <li>Eclipse: Long-standing, open-source IDE, primarily known for Java but supports many languages via plugins.</li> <li>Visual Studio (Not VS Code): Microsoft's flagship IDE, primarily for .NET (C#), C++, and Windows development. Offers a free Community edition.</li> </ul> </li> </ul>"},{"location":"baseline/dev/ides/#choosing-the-right-tool","title":"Choosing the Right Tool","text":"<p>There's no single \"best\" tool; the right choice depends on:</p> <ul> <li>Project Complexity: Simple scripts might only need Nano or Vim, while large applications benefit from an IDE.</li> <li>Programming Language: Some IDEs offer superior support for specific languages (e.g., PyCharm for Python).</li> <li>Personal Preference: Do you prefer a lightweight, customizable tool or an all-in-one suite?</li> <li>Team Standards: Your team might have a preferred editor or IDE.</li> <li>Learning Curve: Some tools (Vim, Emacs) require more initial effort than others (VS Code, Sublime Text).</li> </ul>"},{"location":"baseline/dev/ides/#key-features-to-look-for","title":"Key Features to Look For","text":"<p>Regardless of your choice, look for these essential features (often available via plugins in text editors):</p> <ul> <li>Syntax Highlighting: Makes code easier to read.</li> <li>Code Completion (IntelliSense): Suggests code as you type, speeding up development and reducing typos.</li> <li>Linting &amp; Formatting: Helps enforce code style consistency and catch potential errors early (e.g., using tools like ESLint, Flake8, Prettier).</li> <li>Debugging Integration: Ability to set breakpoints, step through code, and inspect variables.</li> <li>Version Control Integration: Built-in support for Git commands (staging, committing, viewing diffs).</li> <li>Extensibility: Ability to add features through plugins or extensions.</li> </ul> <p>The best way to find the right tool is to experiment! Try out a few popular options for your preferred language and see which one feels most comfortable and productive for your workflow. Many developers use both a powerful text editor for quick tasks and an IDE for larger projects.</p>"},{"location":"baseline/dev/secure_coding/","title":"Building Securely: Introduction to Secure Coding Practices","text":"<p>Writing functional code isn't enough; developers must also write secure code. Security vulnerabilities can lead to data breaches, financial loss, reputational damage, and loss of user trust. Secure coding involves building security considerations into every stage of the development lifecycle. It's a mindset, not an afterthought.</p>"},{"location":"baseline/dev/secure_coding/#why-secure-coding-matters","title":"Why Secure Coding Matters","text":"<ul> <li>Protect Data: Prevent unauthorized access, modification, or theft of sensitive user or company data.</li> <li>Maintain Availability: Ensure your application remains operational and isn't taken down by attacks.</li> <li>Preserve Integrity: Ensure data and system operations haven't been tampered with.</li> <li>Build Trust: Users trust applications that protect their information.</li> <li>Compliance: Many regulations (like GDPR, HIPAA) mandate security practices.</li> </ul>"},{"location":"baseline/dev/secure_coding/#core-security-principles","title":"Core Security Principles","text":"<p>Incorporate these principles into your development habits:</p> <ul> <li>Validate Input: Never trust user input. Assume all external input (from users, files, network requests, environment variables) is potentially malicious. Sanitize and validate input rigorously on the server-side before using it. This is the primary defense against injection attacks.</li> <li>Principle of Least Privilege: Grant users, processes, or components only the minimum permissions necessary to perform their intended function. Avoid running processes as root or admin unless absolutely required.</li> <li>Defense in Depth: Don't rely on a single security control. Use multiple layers of defense (e.g., input validation + parameterized queries + web application firewall). If one layer fails, others might still protect the system.</li> <li>Secure Defaults: Configure applications and systems to be secure by default. Users shouldn't have to take extra steps to secure the basic setup.</li> <li>Fail Securely: When errors occur, ensure the application fails in a way that doesn't expose sensitive information (e.g., avoid detailed error messages in production) or leave the system in an insecure state.</li> <li>Keep Secrets Secure: Never hardcode sensitive information like passwords, API keys, or encryption keys directly in source code. Use secure methods like environment variables, configuration files with restricted permissions, or dedicated secrets management systems (e.g., HashiCorp Vault, AWS Secrets Manager).</li> <li>Separation of Duties: Split critical functions among multiple roles or components to prevent a single point of compromise.</li> <li>Secure Communication: Always use secure protocols (e.g., HTTPS, SSH, TLS) for data in transit. Avoid transmitting sensitive data over unencrypted channels.</li> <li>Minimize Attack Surface: Only expose necessary endpoints, features, and services. Disable or remove unused code, services, and ports.</li> </ul>"},{"location":"baseline/dev/secure_coding/#common-vulnerabilities-to-understand","title":"Common Vulnerabilities to Understand","text":"<p>Familiarize yourself with the OWASP Top 10 and other common attack vectors:</p> <ul> <li>Injection Attacks (e.g., SQL Injection, Command Injection): Occur when untrusted input is mistakenly interpreted as part of a command or query. Defense: Input validation, parameterized queries/prepared statements.</li> <li>Cross-Site Scripting (XSS): Injecting malicious scripts into web pages viewed by other users. Defense: Input validation, output encoding (escaping special characters in HTML/JS context).</li> <li>Cross-Site Request Forgery (CSRF): Tricks a user into submitting unwanted actions on a web application where they're authenticated. Defense: Use anti-CSRF tokens, check referer headers.</li> <li>Broken Authentication: Flaws in login, session management, or password recovery mechanisms. Defense: Strong password policies, multi-factor authentication, secure session handling.</li> <li>Broken Access Control (e.g., Insecure Direct Object References - IDOR): Allowing users to access resources or perform actions they shouldn't be authorized for. Defense: Enforce authorization checks on the server-side for every request.</li> <li>Security Misconfiguration: Incorrectly configured security settings in the application, web server, database, or framework. Defense: Secure defaults, regular audits, automated configuration checks.</li> <li>Sensitive Data Exposure: Failing to protect sensitive data at rest or in transit. Defense: Encryption, secure storage, secure transmission.</li> <li>Using Components with Known Vulnerabilities: Relying on outdated or insecure third-party libraries or frameworks. Defense: Regularly scan dependencies and update them promptly.</li> <li>Insufficient Logging &amp; Monitoring: Not detecting or responding to security breaches. Defense: Implement logging, alerting, and regular review of logs.</li> </ul>"},{"location":"baseline/dev/secure_coding/#secure-coding-practices-by-language","title":"Secure Coding Practices by Language","text":"<ul> <li>Web (JavaScript/Node.js): Use frameworks that auto-escape output, avoid <code>eval</code>, use helmet.js for HTTP headers, sanitize user input.</li> <li>Python: Use parameterized queries with ORMs, avoid <code>exec</code>/<code>eval</code>, use virtual environments, keep dependencies updated.</li> <li>Java: Use prepared statements, validate all inputs, use security libraries for authentication and encryption.</li> <li>C/C++: Avoid buffer overflows by using safe string functions, validate all input, use memory-safe libraries.</li> </ul>"},{"location":"baseline/dev/secure_coding/#tools-and-practices","title":"Tools and Practices","text":"<ul> <li>Linters &amp; Static Analysis Security Testing (SAST): Tools that analyze source code without running it to find potential security flaws and bad practices. Integrate them into your development workflow and CI/CD pipeline.</li> <li>Dependency Scanning: Tools that check your project's dependencies against databases of known vulnerabilities (e.g., <code>npm audit</code>, <code>safety</code> (Python), Snyk, GitHub Dependabot).</li> <li>Code Reviews: Have peers review your code specifically looking for security issues, not just functional correctness.</li> <li>Secure Frameworks/Libraries: Use frameworks and libraries with built-in security features (e.g., ORMs that help prevent SQLi, templating engines that auto-escape output).</li> <li>Threat Modeling: Proactively think about potential threats and how an attacker might target your application during the design phase.</li> <li>Regular Updates: Keep your operating system, language runtimes, libraries, and frameworks patched and up-to-date.</li> <li>Automated Testing: Include security-focused tests in your test suite (e.g., fuzz testing, penetration testing tools).</li> </ul>"},{"location":"baseline/dev/secure_coding/#secure-coding-checklist","title":"Secure Coding Checklist","text":"<ul> <li> Validate and sanitize all user input.</li> <li> Use parameterized queries for database access.</li> <li> Store secrets securely (never in code).</li> <li> Use HTTPS for all network communication.</li> <li> Apply the principle of least privilege.</li> <li> Keep dependencies up to date and monitor for vulnerabilities.</li> <li> Handle errors securely (no sensitive info in error messages).</li> <li> Log security-relevant events and monitor logs.</li> <li> Regularly review and test your code for security issues.</li> </ul>"},{"location":"baseline/dev/secure_coding/#further-reading-and-resources","title":"Further Reading and Resources","text":"<ul> <li>OWASP Top 10</li> <li>OWASP Secure Coding Practices Checklist</li> <li>Mozilla Secure Coding Guidelines</li> <li>Google\u2019s Security Best Practices</li> </ul> <p>Security is an ongoing process and a fundamental aspect of software quality. By understanding common threats, adopting secure coding principles, and utilizing available tools, you can significantly reduce the risk of vulnerabilities in your applications. Build security in from the start!</p>"},{"location":"baseline/git/git_core_concepts/","title":"Core Git Concepts: Branching, Merging, and More","text":"<p>This page builds upon the basic introduction to Git, exploring the fundamental concepts that give Git its power and flexibility, particularly branching and merging.</p> <p>Prerequisites: Understanding of basic Git concepts (Repository, Commit, Working Directory, Basic Workflow) from the Introduction.</p>"},{"location":"baseline/git/git_core_concepts/#the-staging-area-index-revisited","title":"The Staging Area (Index) Revisited","text":"<p>Before diving into branching, let's clarify the Staging Area (also called the Index). Think of it as a draft space for your next commit.</p> <ul> <li>Purpose: It allows you to group related changes into a single, focused commit, even if you've made other unrelated changes in your working directory. You decide exactly what goes into the snapshot.</li> <li>Command: You use <code>git add &lt;filename&gt;</code> or <code>git add .</code> (to stage all changes in the current directory and subdirectories) to move changes from your Working Directory to the Staging Area.</li> <li>Checking Status: <code>git status</code> shows you which files are modified, staged, or untracked.</li> </ul>"},{"location":"baseline/git/git_core_concepts/#branching-parallel-universes","title":"Branching: Parallel Universes","text":"<p>A branch in Git is essentially a movable pointer to a specific commit. It represents an independent line of development.</p> <ul> <li>Why Branch?<ul> <li>Isolate Work: Develop new features or fix bugs without disrupting the main stable codebase (often the <code>main</code> or <code>master</code> branch).</li> <li>Experimentation: Try out new ideas without consequence if they don't work out.</li> <li>Parallel Development: Multiple team members can work on different features simultaneously on separate branches.</li> </ul> </li> <li><code>main</code> / <code>master</code> Branch: By default, your repository starts with one branch, usually called <code>main</code> (newer standard) or <code>master</code> (older standard). This typically represents the stable, production-ready version of your project.</li> <li>HEAD: This is a special pointer that usually indicates which branch you are currently working on (i.e., your current checked out branch). When you commit, the branch <code>HEAD</code> points to moves forward.</li> <li>Commands:<ul> <li><code>git branch</code>: List all local branches.</li> <li><code>git branch &lt;branch-name&gt;</code>: Create a new branch pointing to the current commit.</li> <li><code>git checkout &lt;branch-name&gt;</code> or <code>git switch &lt;branch-name&gt;</code>: Switch your working directory (and <code>HEAD</code>) to the specified branch.</li> <li><code>git checkout -b &lt;branch-name&gt;</code> or <code>git switch -c &lt;branch-name&gt;</code>: Create a new branch and switch to it immediately.</li> <li><code>git branch -d &lt;branch-name&gt;</code>: Delete a local branch (usually after merging).</li> </ul> </li> </ul>"},{"location":"baseline/git/git_core_concepts/#merging-bringing-work-together","title":"Merging: Bringing Work Together","text":"<p>Once work on a branch is complete, you typically want to integrate those changes back into another branch (like <code>main</code>). This is called merging.</p> <ul> <li>Process:<ol> <li>Switch to the branch you want to merge into (e.g., <code>git switch main</code>).</li> <li>Run the merge command with the name of the branch you want to merge from (e.g., <code>git merge feature-branch</code>).</li> </ol> </li> <li>Types of Merges:<ul> <li>Fast-Forward Merge: If the target branch (<code>main</code>) hasn't diverged (no new commits) since the feature branch was created, Git simply moves the <code>main</code> pointer forward to match the feature branch's pointer. It's a simple, linear history.</li> <li>Three-Way Merge: If both branches have new commits since they diverged, Git creates a new merge commit. This special commit has two parent commits (one from each branch) and integrates the changes from both histories.</li> </ul> </li> </ul>"},{"location":"baseline/git/git_core_concepts/#merge-conflicts-when-worlds-collide","title":"Merge Conflicts: When Worlds Collide","text":"<p>Sometimes, Git can't automatically merge changes because the same lines were modified differently on both branches being merged. This is a merge conflict.</p> <ul> <li>What Happens: Git stops the merge process and marks the conflicting files. Inside these files, you'll see markers like <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, and <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> indicating the conflicting sections from each branch.</li> <li>Resolution:<ol> <li>Open the conflicted file(s) in your editor.</li> <li>Edit the file manually to keep the desired changes, removing the conflict markers.</li> <li>Stage the resolved file(s) using <code>git add &lt;resolved-file&gt;</code>.</li> <li>Commit the merge using <code>git commit</code> (Git usually provides a default merge commit message).</li> </ol> </li> </ul>"},{"location":"baseline/git/git_core_concepts/#rebasing-rewriting-history-use-with-care","title":"Rebasing: Rewriting History (Use with Care!)","text":"<p>Rebasing is an alternative way to integrate changes from one branch onto another. Instead of creating a merge commit, it rewrites the commit history.</p> <ul> <li>How it Works: <code>git rebase &lt;base-branch&gt;</code> (when on your feature branch) takes all the commits unique to your current branch, temporarily removes them, updates your branch to the latest commit from <code>&lt;base-branch&gt;</code>, and then reapplies your unique commits one by one on top of the updated base.</li> <li>Why Rebase? It creates a cleaner, linear project history, making it easier to follow changes compared to potentially complex merge commit graphs. Often used to update a feature branch with the latest changes from <code>main</code> before merging.</li> <li>The Golden Rule: Never rebase commits that have already been pushed and shared with others. Rebasing rewrites history, which can cause significant problems for collaborators who have based their work on the original history. Use <code>merge</code> for shared branches.</li> </ul>"},{"location":"baseline/git/git_core_concepts/#tags-marking-milestones","title":"Tags: Marking Milestones","text":"<p>Tags are used to mark specific, important points in your repository's history, like version releases (e.g., <code>v1.0</code>, <code>v2.1-beta</code>).</p> <ul> <li>Command: <code>git tag &lt;tag-name&gt;</code> (creates a lightweight tag) or <code>git tag -a &lt;tag-name&gt; -m \"Message\"</code> (creates an annotated tag, which is generally recommended as it includes metadata like tagger, date, and message).</li> </ul> <p>Understanding these core concepts, especially branching and merging, is key to leveraging Git effectively for both solo and collaborative projects.</p>"},{"location":"baseline/git/git_introduction/","title":"Introduction to Version Control with Git","text":"<p>Welcome to the world of version control! If you're developing software, managing configurations, or even writing documentation, keeping track of changes over time is crucial. This is where Version Control Systems (VCS) come in, and Git is the most popular one today.</p>"},{"location":"baseline/git/git_introduction/#what-is-version-control","title":"What is Version Control?","text":"<p>Imagine you're working on an important document. You save versions like <code>report_v1.doc</code>, <code>report_v2_final.doc</code>, <code>report_final_REALLY_final.doc</code>. This gets messy quickly, especially if multiple people are working on it.</p> <p>A Version Control System automates this process. It records changes to a file or set of files over time so that you can:</p> <ul> <li>Track History: See who changed what, when, and why.</li> <li>Revert Changes: Go back to previous versions if you make a mistake.</li> <li>Collaborate: Allow multiple people to work on the same project without overwriting each other's work.</li> <li>Branch and Experiment: Create separate lines of development (branches) to work on new features or fixes without affecting the main project, then merge them back in when ready.</li> </ul>"},{"location":"baseline/git/git_introduction/#why-git","title":"Why Git?","text":"<p>There are several VCS options, but Git has become the de-facto standard for many reasons:</p> <ul> <li>Distributed: Unlike older centralized systems, every developer has a full copy of the project history on their local machine. This means you can commit, branch, and view history even when offline. It also provides redundancy.</li> <li>Fast: Most operations (like branching, merging, committing) are incredibly fast because they happen locally.</li> <li>Branching and Merging: Git has a powerful and flexible branching model that encourages experimentation and parallel development.</li> <li>Open Source and Popular: It's free, has a massive community, and integrates with countless tools and platforms (like GitHub, GitLab, Bitbucket).</li> </ul>"},{"location":"baseline/git/git_introduction/#git-hosting-platforms-github-gitlab-bitbucket-and-more","title":"Git Hosting Platforms: GitHub, GitLab, Bitbucket, and More","text":"<p>While Git is the underlying version control system, most teams use a hosting platform to collaborate, manage code, and automate workflows. The most popular platforms include:</p> <ul> <li>GitHub: The largest and most widely used Git hosting service, known for its ease of use, strong community, and integration with countless tools.</li> <li>GitLab: Offers integrated CI/CD, issue tracking, and can be self-hosted for private infrastructure.</li> <li>Bitbucket: Popular in enterprise environments, integrates well with Atlassian tools like Jira.</li> <li>Others: There are additional options like Azure DevOps, Gitea, and more.</li> </ul> <p>Why This Guide Focuses on GitHub</p> <p>While all these platforms offer similar core features, GitHub is the industry standard for open source and is widely used in both personal and professional projects. Its user interface, documentation, and integrations make it an excellent starting point for learning Git-based workflows. Once you understand Git and GitHub, transitioning to other platforms is straightforward.</p>"},{"location":"baseline/git/git_introduction/#core-git-concepts-brief-overview","title":"Core Git Concepts (Brief Overview)","text":"<p>We'll dive deeper into these later, but here are the basics:</p> <ul> <li>Repository (Repo): A directory containing your project files and a hidden <code>.git</code> subdirectory where Git stores all the history and metadata.</li> <li>Working Directory: The actual files and folders you see and edit in your project directory.</li> <li>Staging Area (Index): An intermediate area where you prepare changes before committing them. It allows you to craft your commits precisely.</li> <li>Commit: A snapshot of your project at a specific point in time, saved to the repository's history. Each commit has a unique ID and usually a descriptive message.</li> </ul>"},{"location":"baseline/git/git_introduction/#the-basic-git-workflow","title":"The Basic Git Workflow","text":"<p>The most common workflow involves these steps:</p> <ol> <li>Modify: Make changes to files in your working directory.</li> <li>Stage: Choose which modified files you want to include in your next commit and add them to the staging area (<code>git add &lt;file&gt;</code>).</li> <li>Commit: Take a snapshot of the staged changes and save it permanently to the project history with a descriptive message (<code>git commit -m \"Your message\"</code>).</li> </ol>"},{"location":"baseline/git/git_introduction/#why-learn-git","title":"Why Learn Git?","text":"<p>For developers, knowing Git is practically essential:</p> <ul> <li>Collaboration: It's the backbone of team-based software development.</li> <li>Safety Net: Easily undo mistakes and revert to working versions.</li> <li>Understanding History: Track down when bugs were introduced or why certain changes were made.</li> <li>Experimentation: Work on new ideas safely in branches without risking the main codebase.</li> <li>Employability: It's a required skill for most software development jobs.</li> </ul>"},{"location":"baseline/git/git_practice_and_tests/","title":"Git and GitHub Practice: Self-Test and Exercises","text":"<p>Practice is the best way to learn Git and GitHub. Use these exercises to test your skills and reinforce what you\u2019ve learned.</p>"},{"location":"baseline/git/git_practice_and_tests/#basic-git-tasks","title":"Basic Git Tasks","text":"<ul> <li>Create a New Repository</li> <li>Initialize a new Git repository and make your first commit.</li> <li>Stage and Commit Changes</li> <li>Edit a file, stage it, and commit with a message.</li> <li>Undo Changes</li> <li>Unstage a file (<code>git restore --staged &lt;file&gt;</code>)</li> <li>Amend your last commit (<code>git commit --amend</code>)</li> <li>Revert a commit (<code>git revert &lt;commit-hash&gt;</code>)</li> </ul>"},{"location":"baseline/git/git_practice_and_tests/#branching-and-merging","title":"Branching and Merging","text":"<ul> <li>Create and Switch Branches</li> <li><code>git checkout -b feature-branch</code></li> <li>Merge Branches</li> <li>Merge your feature branch into <code>main</code> and resolve any conflicts.</li> <li>Delete Branches</li> <li><code>git branch -d feature-branch</code></li> </ul>"},{"location":"baseline/git/git_practice_and_tests/#working-with-remotes","title":"Working with Remotes","text":"<ul> <li>Add a Remote and Push</li> <li><code>git remote add origin &lt;url&gt;</code></li> <li><code>git push -u origin main</code></li> <li>Pull Changes</li> <li><code>git pull origin main</code></li> <li>Handle Merge Conflicts</li> <li>Practice resolving a conflict after pulling remote changes.</li> </ul>"},{"location":"baseline/git/git_practice_and_tests/#github-practice","title":"GitHub Practice","text":"<ul> <li>Fork a Repository</li> <li>Fork a public repo and clone it locally.</li> <li>Submit a Pull Request</li> <li>Make a change and open a pull request to the original repo.</li> <li>Open and Close Issues</li> <li>Create an issue and close it after resolving.</li> <li>Assign Reviewers and Labels</li> <li>Assign a teammate to review your pull request and add labels.</li> </ul>"},{"location":"baseline/git/git_practice_and_tests/#self-test-checklist","title":"Self-Test Checklist","text":"<ul> <li> Can you create and clone repositories?</li> <li> Can you stage, commit, and push changes?</li> <li> Can you create, merge, and delete branches?</li> <li> Can you resolve merge conflicts?</li> <li> Can you fork a repo and submit a pull request?</li> <li> Can you use issues and project boards?</li> </ul>"},{"location":"baseline/git/git_practice_and_tests/#further-practice","title":"Further Practice","text":"<ul> <li>Try learngitbranching.js.org for interactive Git challenges.</li> <li>Explore GitHub Skills for guided GitHub learning paths.</li> </ul>"},{"location":"baseline/git/git_remotes/","title":"Working with Remotes in Git","text":"<p>So far, we've mostly focused on using Git locally. However, a major strength of Git is its ability to facilitate collaboration through remote repositories. This page covers how to interact with these remotes.</p> <p>Prerequisites: Understanding of Git basics and core concepts like branching and merging (Introduction, Core Concepts).</p>"},{"location":"baseline/git/git_remotes/#what-are-remote-repositories","title":"What are Remote Repositories?","text":"<p>A remote repository (or \"remote\") is simply a version of your project hosted somewhere else, typically on the internet or a network server. You can have multiple remotes, but often you'll have one primary remote that acts as a central point for collaboration.</p> <ul> <li>Purpose:<ul> <li>Collaboration: Allows multiple developers to share code and contribute to the same project.</li> <li>Backup: Provides an offsite copy of your project history.</li> <li>Integration: Platforms hosting remotes often provide additional tools (issue tracking, CI/CD, code review).</li> </ul> </li> <li>Hosting Platforms: Popular platforms for hosting remote Git repositories include GitHub, GitLab, and Bitbucket.</li> </ul>"},{"location":"baseline/git/git_remotes/#managing-remotes","title":"Managing Remotes","text":"<p>You interact with remotes using the <code>git remote</code> command.</p> <ul> <li>Adding a Remote: Connect your local repository to a remote one.     <pre><code># Syntax: git remote add &lt;shortname&gt; &lt;url&gt;\ngit remote add origin [https://github.com/your-username/your-repo.git](https://github.com/your-username/your-repo.git)\n</code></pre><ul> <li><code>&lt;shortname&gt;</code>: A local alias for the remote URL (conventionally <code>origin</code> for the primary remote).</li> <li><code>&lt;url&gt;</code>: The URL of the remote repository (usually found on the hosting platform).</li> </ul> </li> <li>Viewing Remotes: See which remotes are configured.     <pre><code>git remote -v\n</code></pre>     This shows the shortname and URL for fetch and push operations.</li> <li>Renaming a Remote:     <pre><code>git remote rename &lt;old-name&gt; &lt;new-name&gt;\n</code></pre></li> <li>Removing a Remote:     <pre><code>git remote remove &lt;shortname&gt;\n</code></pre></li> </ul>"},{"location":"baseline/git/git_remotes/#getting-changes-from-a-remote-fetching-and-pulling","title":"Getting Changes from a Remote: Fetching and Pulling","text":"<p>To update your local repository with changes from a remote:</p> <ul> <li>`git fetch &lt;remote-name:<ul> <li>Downloads commits and objects from the remote repository that you don't have locally.</li> <li>Updates your remote-tracking branches (e.g., <code>origin/main</code>). These are local pointers to the state of the branches on the remote the last time you fetched.</li> <li>Crucially, <code>git fetch</code> does NOT modify your local working directory or your local branches (like <code>main</code>). It just gets the data.</li> <li>Useful to see what has changed on the remote before deciding how to integrate it.</li> </ul> </li> <li><code>git pull &lt;remote-name&gt; &lt;branch-name&gt;</code>:<ul> <li>Essentially performs a <code>git fetch</code> followed by a <code>git merge</code> (or <code>git rebase</code>, if configured).</li> <li>It fetches changes from the specified remote branch and immediately tries to integrate them into your current local branch.</li> <li>Example: If you are on your local <code>main</code> branch, <code>git pull origin main</code> fetches <code>origin/main</code> and merges it into your local <code>main</code>.</li> <li>This is a common way to update your local branch, but be aware it triggers an immediate merge (which might result in conflicts).</li> </ul> </li> </ul>"},{"location":"baseline/git/git_remotes/#sending-changes-to-a-remote-pushing","title":"Sending Changes to a Remote: Pushing","text":"<p>Once you have committed changes locally, you can share them by pushing them to a remote.</p> <ul> <li><code>git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</code>:<ul> <li>Uploads your local branch commits to the specified remote branch.</li> <li>Often simplified to <code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code> if the local and remote branch names are the same.</li> <li>Example: <code>git push origin main</code> pushes your local <code>main</code> branch to the <code>main</code> branch on the <code>origin</code> remote.</li> </ul> </li> <li>Setting Upstream: The first time you push a new local branch, you might use the <code>-u</code> flag:     <pre><code>git push -u origin feature-branch\n</code></pre>     This sets up a tracking relationship between your local <code>feature-branch</code> and <code>origin/feature-branch</code>. After this, you can often just run <code>git push</code> (and <code>git pull</code>) from that branch without specifying the remote and branch names.</li> <li>Push Rejection: Git will prevent you from pushing if the remote branch has commits that you don't have locally (i.e., the histories have diverged). You need to <code>pull</code> (or <code>Workspace</code> and <code>merge</code>/<code>rebase</code>) the remote changes first, integrate them with your local changes, and then push.</li> </ul>"},{"location":"baseline/git/git_remotes/#cloning-getting-started-with-a-remote-project","title":"Cloning: Getting Started with a Remote Project","text":"<p>If a project already exists on a remote server, the easiest way to get a local copy is to clone it.</p> <ul> <li><code>git clone &lt;repository-url&gt;</code>:<ul> <li>Creates a full copy of the remote repository on your local machine.</li> <li>Automatically sets up the original URL as the <code>origin</code> remote.</li> <li>Checks out the default branch (usually <code>main</code> or <code>master</code>).</li> </ul> </li> </ul>"},{"location":"baseline/git/git_remotes/#collaboration-workflows","title":"Collaboration Workflows","text":"<p>Remotes enable various team workflows. Two common patterns are:</p> <ul> <li>Feature Branch Workflow:<ol> <li>Create a new branch locally for each feature or bug fix.</li> <li>Develop and commit changes on that branch.</li> <li>Push the feature branch to the remote repository.</li> <li>Open a Pull Request (PR) or Merge Request (MR) on the hosting platform (GitHub/GitLab). This is a formal request to merge your feature branch into the main branch, allowing for code review and discussion before merging.</li> <li>Once approved, the branch is merged (often via the web interface).</li> </ol> </li> <li>Forking Workflow: (Common in open-source)<ol> <li>Create a personal copy (fork) of the main repository on the hosting platform.</li> <li>Clone your fork locally.</li> <li>Create feature branches, commit, and push to your fork.</li> <li>Open a Pull Request from your fork's branch back to the original repository.</li> </ol> </li> </ul> <p>Interacting with remotes is fundamental for collaborative development and backing up your work. Mastering <code>Workspace</code>, <code>pull</code>, <code>push</code>, and understanding workflows like Pull Requests is essential.</p>"},{"location":"baseline/git/git_troubleshooting/","title":"Git Troubleshooting and Common Pitfalls","text":"<p>Even experienced Git users run into problems from time to time. This page covers common issues, error messages, and how to recover from mistakes.</p>"},{"location":"baseline/git/git_troubleshooting/#resolving-merge-conflicts","title":"Resolving Merge Conflicts","text":"<p>When two branches change the same part of a file, Git can\u2019t merge automatically.</p> <p>How to resolve:</p> <ol> <li>Git will mark the conflicted files. Open them and look for <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, and <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>.</li> <li>Edit the file to keep the correct changes.</li> <li>Stage the resolved file: <pre><code>git add &lt;file&gt;\n</code></pre></li> <li>Complete the merge: <pre><code>git commit\n</code></pre></li> </ol>"},{"location":"baseline/git/git_troubleshooting/#undoing-commits","title":"Undoing Commits","text":"<ul> <li>Undo the last commit (keep changes staged): <pre><code>git reset --soft HEAD~1\n</code></pre></li> <li>Undo the last commit (keep changes unstaged): <pre><code>git reset --mixed HEAD~1\n</code></pre></li> <li>Undo the last commit (discard changes): <pre><code>git reset --hard HEAD~1\n</code></pre></li> <li>Revert a specific commit (safe for shared history): <pre><code>git revert &lt;commit-hash&gt;\n</code></pre></li> </ul>"},{"location":"baseline/git/git_troubleshooting/#recovering-lost-commits-with-reflog","title":"Recovering Lost Commits with Reflog","text":"<p>If you lose a branch or commit, use <code>git reflog</code> to find its reference and recover it.</p> <pre><code>git reflog\ngit checkout &lt;commit-hash&gt;\n</code></pre>"},{"location":"baseline/git/git_troubleshooting/#fixing-detached-head-state","title":"Fixing Detached HEAD State","text":"<p>If you see \u201cdetached HEAD\u201d, you\u2019re not on a branch.</p> <ul> <li>To save your work: <pre><code>git checkout -b my-new-branch\n</code></pre></li> </ul>"},{"location":"baseline/git/git_troubleshooting/#dealing-with-accidental-pushes","title":"Dealing with Accidental Pushes","text":"<ul> <li>Undo a pushed commit (if safe): <pre><code>git revert &lt;commit-hash&gt;\ngit push origin main\n</code></pre></li> <li>Force push (dangerous, avoid on shared branches): <pre><code>git push --force\n</code></pre></li> </ul>"},{"location":"baseline/git/git_troubleshooting/#permission-errors","title":"Permission Errors","text":"<ul> <li>Check your SSH keys: <pre><code>ssh -T git@github.com\n</code></pre></li> <li>Update remote URL to use SSH or HTTPS as needed.</li> </ul>"},{"location":"baseline/git/git_troubleshooting/#more-resources","title":"More Resources","text":"<ul> <li>GitHub Docs: Resolving merge conflicts</li> <li>Atlassian Git Tutorials: Reset, Revert, and Checkout</li> </ul>"},{"location":"baseline/git/git_useful_commands/","title":"Useful Git Commands Beyond the Basics","text":"<p>You've learned the basic Git workflow, core concepts like branching/merging, and how to work with remotes. This page introduces some additional commands and options that help you inspect history, manage changes, and troubleshoot more effectively.</p> <p>Prerequisites: Understanding of Git basics, core concepts, and remotes (Introduction, Core Concepts, Remotes).</p>"},{"location":"baseline/git/git_useful_commands/#inspecting-history","title":"Inspecting History","text":"<p>The <code>git log</code> command is your window into the project's history. It has many powerful options:</p> <ul> <li>Basic Usage: <code>git log</code> shows commits in reverse chronological order (newest first), including commit hash, author, date, and commit message.</li> <li>Common Formatting Options:<ul> <li><code>git log --oneline</code>: Shows each commit as a single line (short hash and message). Great for a quick overview.</li> <li><code>git log --graph</code>: Displays an ASCII graph showing branch and merge history. Often combined with <code>--oneline</code> and <code>--decorate</code> (shows branch/tag names): <code>git log --graph --oneline --decorate</code>.</li> <li><code>git log --stat</code>: Shows basic stats about which files were changed in each commit and how many lines were added/removed.</li> <li><code>git log -p</code> or <code>git log --patch</code>: Shows the full diff (changes introduced) for each commit.</li> </ul> </li> <li>Filtering Commits:<ul> <li><code>git log -n &lt;number&gt;</code> or <code>git log -&lt;number&gt;</code>: Limit output to the specified number of commits (e.g., <code>git log -5</code>).</li> <li><code>git log --author=\"&lt;pattern&gt;\"</code>: Show commits by a specific author.</li> <li><code>git log --grep=\"&lt;pattern&gt;\"</code>: Show commits where the message matches the pattern.</li> <li><code>git log --since=\"&lt;date&gt;\" --until=\"&lt;date&gt;\"</code>: Show commits within a date range (e.g., <code>\"2 weeks ago\"</code>, <code>\"2025-01-01\"</code>).</li> <li><code>git log &lt;branch-or-commit&gt;..&lt;branch-or-commit&gt;</code>: Show commits reachable from the second reference but not the first.</li> <li><code>git log -- &lt;path/to/file&gt;</code>: Show commits that affected a specific file or directory.</li> </ul> </li> </ul>"},{"location":"baseline/git/git_useful_commands/#comparing-changes","title":"Comparing Changes","text":"<p>The <code>git diff</code> command shows differences between various states in your repository.</p> <ul> <li>Working Directory vs. Staging Area: <code>git diff</code> shows changes in tracked files that are modified but not yet staged.</li> <li>Staging Area vs. Last Commit: <code>git diff --staged</code> (or <code>git diff --cached</code>) shows changes that are staged but not yet committed. This shows what will be in your next commit if you run <code>git commit</code> now.</li> <li>Between Commits: <code>git diff &lt;commit1&gt; &lt;commit2&gt;</code> shows the differences introduced between two specific commits.</li> <li>Between Branches: <code>git diff &lt;branch1&gt;..&lt;branch2&gt;</code> shows the differences between the tips of two branches.</li> <li>Ignoring Whitespace: Add <code>-w</code> or <code>--ignore-all-space</code> to ignore whitespace changes.</li> </ul>"},{"location":"baseline/git/git_useful_commands/#temporarily-saving-changes","title":"Temporarily Saving Changes","text":"<p>Sometimes you need to quickly switch branches, but you have uncommitted changes in your working directory or staging area that you're not ready to commit yet. <code>git stash</code> is perfect for this.</p> <ul> <li>Purpose: It takes your modified tracked files and staged changes, saves them away on a stack of unfinished changes, and reverts your working directory to match the <code>HEAD</code> commit (like it was clean).</li> <li>Commands:<ul> <li><code>git stash push -m \"Optional message\"</code> or just <code>git stash</code>: Save current changes to the stash.</li> <li><code>git stash list</code>: Show all the stashes you've saved.</li> <li><code>git stash apply &lt;stash-id&gt;</code>: Reapply the changes from a specific stash (e.g., <code>stash@{0}</code>) to your working directory without removing it from the stash list.</li> <li><code>git stash pop &lt;stash-id&gt;</code>: Reapply changes and remove the stash from the list (most common). If no ID is given, it applies/pops the latest stash (<code>stash@{0}</code>).</li> <li><code>git stash drop &lt;stash-id&gt;</code>: Delete a specific stash from the list.</li> <li><code>git stash clear</code>: Delete all stashes.</li> </ul> </li> </ul>"},{"location":"baseline/git/git_useful_commands/#finding-faulty-commits","title":"Finding Faulty Commits","text":"<p>If you discover a bug but don't know which commit introduced it, <code>git bisect</code> can help you find it quickly using a binary search through your commit history.</p> <ul> <li>Concept: You tell Git a \"bad\" commit (where the bug exists) and a \"good\" commit (before the bug existed). Git then checks out a commit halfway between them and asks you if it's good or bad. Based on your answer, it narrows down the range until it pinpoints the exact commit that introduced the problem.</li> <li>Basic Workflow:<ol> <li><code>git bisect start</code>: Begin the bisect session.</li> <li><code>git bisect bad</code>: Mark the current commit (or specify one) as having the bug.</li> <li><code>git bisect good &lt;commit-id&gt;</code>: Mark a known commit before the bug existed as good.</li> <li>Git checks out a commit in the middle. Test your code now.</li> <li>Tell Git the result: <code>git bisect good</code> or <code>git bisect bad</code>.</li> <li>Repeat steps 4 &amp; 5 until Git tells you which commit is the first bad one.</li> <li><code>git bisect reset</code>: End the bisect session and return to your original branch/commit.</li> </ol> </li> </ul>"},{"location":"baseline/git/git_useful_commands/#cleaning-up","title":"Cleaning Up","text":"<p>This command removes untracked files from your working directory. Useful for getting a truly clean state, but dangerous because it can permanently delete files not tracked by Git.</p> <ul> <li>Always Preview First: <code>git clean -n</code> (or <code>--dry-run</code>) shows you what would be deleted without actually deleting anything.</li> <li>Common Usage:<ul> <li><code>git clean -f</code>: Force removal of untracked files.</li> <li><code>git clean -fd</code>: Force removal of untracked files and directories.</li> <li><code>git clean -fx</code>: Force removal of untracked files, even those ignored by <code>.gitignore</code>. Be very careful!</li> </ul> </li> </ul>"},{"location":"baseline/git/git_useful_commands/#rewriting-history-brief-mention","title":"Rewriting History (Brief Mention)","text":"<p>Commands like <code>git commit --amend</code> (modify the most recent commit) and <code>git rebase -i</code> (interactive rebase - allows squashing, reordering, editing commits) are powerful but rewrite history. Use them cautiously, especially on commits already pushed to a remote. These are generally considered more advanced topics.</p> <p>These commands provide more control and insight into your Git repository, helping you manage history, compare changes, and troubleshoot effectively. Explore their <code>man</code> pages (<code>man git-log</code>, <code>man git-diff</code>, etc.) or use <code>--help</code> for even more options.</p>"},{"location":"baseline/git/github_overview/","title":"GitHub Overview: From Getting Started to Advanced","text":"<p>GitHub is the world\u2019s most popular platform for hosting and collaborating on Git repositories. Whether you\u2019re a beginner or an experienced developer, mastering GitHub will help you collaborate, contribute to open source, and automate your workflows.</p>"},{"location":"baseline/git/github_overview/#what-is-github","title":"What is GitHub?","text":"<p>GitHub is a web-based platform that hosts Git repositories and provides tools for collaboration, code review, issue tracking, and automation.</p> <ul> <li>Public and Private Repositories: Host open source or private projects.</li> <li>Collaboration: Work with others using pull requests, issues, and project boards.</li> <li>Automation: Use GitHub Actions for CI/CD and workflow automation.</li> </ul>"},{"location":"baseline/git/github_overview/#getting-started-with-github","title":"Getting Started with GitHub","text":"<ol> <li>Create a GitHub Account    Sign up at github.com.</li> <li>Set Up SSH Keys    Securely connect your computer to GitHub.  </li> <li>GitHub Docs: Connecting to GitHub with SSH</li> <li>Create Your First Repository </li> <li>Click \"New\" on your GitHub dashboard.</li> <li>Name your repository and choose public/private.</li> <li>Clone a Repository <pre><code>git clone git@github.com:your-username/your-repo.git\n</code></pre></li> <li>Push Your First Commit <pre><code>git add .\ngit commit -m \"Initial commit\"\ngit push origin main\n</code></pre></li> </ol>"},{"location":"baseline/git/github_overview/#intermediate-github","title":"Intermediate GitHub","text":"<ul> <li>Forking Repositories: Copy someone else\u2019s repo to your account to propose changes.</li> <li>Pull Requests: Suggest changes to a project.  </li> <li>Issues and Project Boards: Track bugs, features, and organize work.</li> <li>Managing Collaborators: Add teammates and set permissions.</li> </ul>"},{"location":"baseline/git/github_overview/#advanced-github","title":"Advanced GitHub","text":"<ul> <li>GitHub Actions: Automate builds, tests, and deployments.</li> <li>Branch Protection Rules: Enforce code review and CI before merging.</li> <li>Releases and Tags: Mark important versions of your code.</li> <li>GitHub CLI: Use GitHub from the command line.</li> <li>Security Features: Enable Dependabot and code scanning.</li> </ul>"},{"location":"baseline/git/github_overview/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ul> <li>Write clear commit messages and pull request descriptions.</li> <li>Keep your README up to date.</li> <li>Use issues and labels to organize work.</li> <li>Respect open source etiquette when contributing.</li> </ul>"},{"location":"baseline/networking/net_intro/","title":"Introduction to Basic Networking in Linux","text":"<p>Networking is the cornerstone of our modern digital world. It connects devices, enabling them to share resources, communicate, and interact seamlessly. Whether you're browsing the web, streaming videos, or managing cloud-based servers, networking is at the heart of these activities.</p>"},{"location":"baseline/networking/net_intro/#why-is-networking-important","title":"Why is Networking Important?","text":"<p>Understanding networking is critical because it serves as the foundation for almost every aspect of IT infrastructure.</p> <p>Networking allows:</p> <ul> <li>Communication: Devices exchange information using structured protocols.</li> <li>Resource Sharing: Printers, file servers, and databases are accessible across networks.</li> <li>Problem Solving: Troubleshooting connectivity issues requires a grasp of core networking concepts.</li> </ul> <p>For Linux users, networking knowledge is even more vital. Linux powers most servers, cloud platforms, and networking hardware, making it a dominant force in the tech industry.</p>"},{"location":"baseline/networking/net_intro/#why-learn-networking-in-linux","title":"Why Learn Networking in Linux?","text":"<p>Learning networking in Linux equips you with the skills to:</p> <ol> <li>Manage Servers: Configure, secure, and maintain Linux-based systems.</li> <li>Troubleshoot Connectivity: Use Linux tools to diagnose and resolve network issues.</li> <li>Enhance Security: Understand secure communication methods like SSH and key management.</li> </ol> <p>This series covers three essential topics to kickstart your networking journey:</p> <ol> <li>Networking Concepts: Learn the building blocks like IP addresses, DNS, and protocols.</li> <li>Linux Networking Commands: Master tools for monitoring and troubleshooting networks.</li> <li>SSH (Secure Shell): Discover secure ways to access and manage remote Linux systems.</li> </ol> <p>By the end, you'll have a solid foundation in Linux networking that will set you on the path to success.</p>"},{"location":"baseline/networking/network_models/","title":"Understanding the OSI and TCP/IP Models in Networking","text":"<p>Networking is a complex field, but frameworks like the OSI (Open Systems Interconnection) Model and the TCP/IP Model help simplify it by organizing communication processes into layers. This document explores both models, highlighting their differences, similarities, and practical applications.</p>"},{"location":"baseline/networking/network_models/#the-osi-model","title":"The OSI Model","text":"<p>The OSI Model is a conceptual framework that divides the networking process into seven layers, each with a specific responsibility. It helps standardize communication and troubleshoot networking issues.</p>"},{"location":"baseline/networking/network_models/#the-seven-layers-of-the-osi-model","title":"The Seven Layers of the OSI Model","text":""},{"location":"baseline/networking/network_models/#1-physical-layer","title":"1. Physical Layer","text":"<p>Handles the actual physical connection between devices. It deals with raw data (bits) and the hardware components such as cables, switches, and wireless signals.</p> <ul> <li>Examples: Ethernet cables, Wi-Fi, fiber optics.</li> <li>Troubleshoot: Check cables, signal strength, or hardware issues.</li> </ul>"},{"location":"baseline/networking/network_models/#2-data-link-layer","title":"2. Data Link Layer","text":"<p>Responsible for transferring data between devices on the same network. It organizes data into frames and manages MAC (Media Access Control) addresses.</p> <ul> <li>Examples: Ethernet, Wi-Fi (802.11 standards).</li> <li>Troubleshoot: Use tools like <code>ifconfig</code> or <code>ip addr</code> to verify network interface settings.</li> </ul>"},{"location":"baseline/networking/network_models/#3-network-layer","title":"3. Network Layer","text":"<p>Handles routing and IP addressing to enable communication between devices on different networks.</p> <ul> <li>Examples: IPv4, IPv6, routers.</li> <li>Troubleshoot: Use commands like <code>ping</code>, <code>traceroute</code>, or <code>ip route</code>.</li> </ul>"},{"location":"baseline/networking/network_models/#4-transport-layer","title":"4. Transport Layer","text":"<p>Ensures that messages are delivered error-free, in sequence, and without losses. It uses protocols like TCP (reliable) and UDP (fast but unreliable).</p> <ul> <li>Examples: TCP, UDP.</li> <li>Troubleshoot: Use tools like <code>netstat</code> or <code>ss</code> to examine open ports and connections.</li> </ul>"},{"location":"baseline/networking/network_models/#5-session-layer","title":"5. Session Layer","text":"<p>Manages sessions or connections between applications. It handles opening, maintaining, and closing communication sessions.</p> <ul> <li>Examples: APIs, session management in web browsers.</li> <li>Troubleshoot: Check session timeouts or application logs.</li> </ul>"},{"location":"baseline/networking/network_models/#6-presentation-layer","title":"6. Presentation Layer","text":"<p>Prepares data for the application layer by translating it into a format the application can understand. It handles encryption, compression, and data formatting.</p> <ul> <li>Examples: SSL/TLS (encryption), JPEG (image compression).</li> <li>Troubleshoot: Check for encryption or data corruption issues.</li> </ul>"},{"location":"baseline/networking/network_models/#7-application-layer","title":"7. Application Layer","text":"<p>This is the layer closest to the user. It provides network services to applications, such as web browsing or email.</p> <ul> <li>Examples: HTTP, FTP, SMTP, DNS.</li> <li>Troubleshoot: Use tools like <code>curl</code> or <code>nslookup</code> to verify application protocols.</li> </ul>"},{"location":"baseline/networking/network_models/#the-tcpip-model","title":"The TCP/IP Model","text":"<p>The TCP/IP Model is a simplified framework used to describe how data travels across networks. Unlike the OSI model, it has only four layers, combining some of the OSI layers into broader categories.</p>"},{"location":"baseline/networking/network_models/#the-four-layers-of-the-tcpip-model","title":"The Four Layers of the TCP/IP Model","text":""},{"location":"baseline/networking/network_models/#1-application-layer","title":"1. Application Layer","text":"<p>Combines the Application, Presentation, and Session layers of the OSI model. It handles high-level protocols, data representation, and session communication.</p> <ul> <li>Examples: HTTP, FTP, SMTP, DNS, SSL/TLS.</li> <li>Troubleshoot: Issues with applications or protocols like web browsing (HTTP) or email (SMTP).</li> </ul>"},{"location":"baseline/networking/network_models/#2-transport-layer","title":"2. Transport Layer","text":"<p>Corresponds directly to the Transport Layer in the OSI model. It ensures reliable communication (via TCP) or fast, connectionless communication (via UDP).</p> <ul> <li>Examples: TCP, UDP.</li> <li>Troubleshoot: Issues with dropped packets, retransmissions, or slow connections.</li> </ul>"},{"location":"baseline/networking/network_models/#3-internet-layer","title":"3. Internet Layer","text":"<p>Maps to the Network Layer in the OSI model. It handles IP addressing and routing.</p> <ul> <li>Examples: IPv4, IPv6, ICMP.</li> <li>Troubleshoot: Use tools like <code>ping</code> or <code>traceroute</code> to verify routing and connectivity.</li> </ul>"},{"location":"baseline/networking/network_models/#4-network-access-layer","title":"4. Network Access Layer","text":"<p>Combines the Data Link and Physical layers of the OSI model. It deals with hardware and low-level protocols.</p> <ul> <li>Examples: Ethernet, Wi-Fi, ARP.</li> <li>Troubleshoot: Check network interfaces, cables, or wireless connections.</li> </ul>"},{"location":"baseline/networking/network_models/#comparing-the-osi-and-tcpip-models","title":"Comparing the OSI and TCP/IP Models","text":"Feature OSI Model TCP/IP Model Number of Layers Seven Four Application Layers Application, Presentation, Session Application Transport Layer Transport Transport Network Layer Network Internet Data Link/Physical Data Link, Physical Network Access"},{"location":"baseline/networking/network_models/#key-notes","title":"Key Notes:","text":"<ol> <li>The OSI model is more detailed, making it useful for learning and understanding networking concepts.</li> <li>The TCP/IP model is more practical and aligns with real-world implementations.</li> </ol>"},{"location":"baseline/networking/network_models/#visualizing-the-osi-and-tcpip-models","title":"Visualizing the OSI and TCP/IP Models","text":"<p>Here\u2019s a comparison of the two models:</p> <pre><code>+-------------------+--------------------------------+-----------------------+\n| OSI Model         | Example Protocols/Technologies | TCP/IP Model          |\n+-------------------+--------------------------------+-----------------------+\n| Application       | HTTP, FTP, SMTP, DNS           |                       |\n+-------------------+--------------------------------+       \u2191               |\n| Presentation      | SSL/TLS, JPEG, ASCII           | Application           |\n+-------------------+--------------------------------+       \u2191               |\n| Session           | APIs, session management       |                       |\n+-------------------+--------------------------------+-----------------------+\n| Transport         | TCP, UDP                       | Transport             |\n+-------------------+--------------------------------+-----------------------+\n| Network           | IPv4, IPv6, ICMP               | Internet              |\n+-------------------+--------------------------------+-----------------------+\n| Data Link         | Ethernet, Wi-Fi                |       \u2193               |\n| Physical          | Cables, Wireless, Fiber Optic  | Network Access (Link) |\n+-------------------+--------------------------------+-----------------------+\n</code></pre>"},{"location":"baseline/networking/network_models/#how-the-models-work-in-practice","title":"How the Models Work in Practice","text":"<p>Example: Sending a Web Request</p> OSI ModelTCP/IP Model <ol> <li>Application Layer (7): Your browser sends an HTTP request.</li> <li>Presentation Layer (6): The data is encrypted using SSL/TLS.</li> <li>Session Layer (5): A session is established between your browser and the remote server.</li> <li>Transport Layer (4): TCP ensures the data is split into packets and sent reliably.</li> <li>Network Layer (3): Each packet is assigned an IP address and routed to the destination.</li> <li>Data Link Layer (2): The packets are framed and sent over the local network.</li> <li>Physical Layer (1): The data travels as electrical signals or wireless waves.</li> </ol> <ol> <li>Application Layer: Your browser sends an HTTP request.</li> <li>Transport Layer: TCP splits the data into packets.</li> <li>Internet Layer: IP assigns an address and routes the packets.</li> <li>Network Access Layer: The packets are sent over the hardware (e.g., Ethernet or Wi-Fi).</li> </ol>"},{"location":"baseline/networking/network_models/#why-learn-both-models","title":"Why Learn Both Models?","text":"<ol> <li>Troubleshooting: The OSI model provides a detailed framework for pinpointing issues, while the TCP/IP model reflects real-world implementations.</li> <li>Standardization: Both models help understand how protocols and devices interact.</li> <li>Foundation for Networking: Together, they provide a comprehensive understanding of networking principles.</li> </ol> <p>By mastering both the OSI and TCP/IP models, you\u2019ll have the knowledge to diagnose and solve network issues effectively.</p>"},{"location":"baseline/networking/networking_commands/","title":"Linux Networking Commands","text":"<p>Linux provides powerful tools for monitoring, diagnosing, and troubleshooting network issues. Below, we explore essential commands and how to use them effectively.</p>"},{"location":"baseline/networking/networking_commands/#checking-connectivity","title":"Checking Connectivity","text":"pingtraceroute <ul> <li>Usage: Test connectivity to a host.   <pre><code>ping google.com\n</code></pre></li> <li>Sends ICMP packets to the destination and measures the response time.</li> <li> <p>Use <code>Ctrl+C</code> to stop the command.</p> </li> <li> <p>Troubleshooting Example:</p> <ul> <li>If <code>ping</code> fails, it could indicate:</li> <li>Network connectivity issues.</li> <li>DNS resolution problems.</li> </ul> </li> </ul> <ul> <li>Usage: Trace the path packets take to a destination.   <pre><code>traceroute google.com\n</code></pre></li> <li> <p>Identifies where delays or failures occur in the route.</p> </li> <li> <p>Troubleshooting Example:</p> <ul> <li>Use <code>traceroute</code> to pinpoint where packets are getting dropped.</li> </ul> </li> </ul>"},{"location":"baseline/networking/networking_commands/#viewing-network-configuration","title":"Viewing Network Configuration","text":"ip addrifconfig (Deprecated) <ul> <li>Usage: Display network interfaces and IP addresses.   <pre><code>ip addr\n</code></pre></li> <li> <p>Look for <code>inet</code> to find assigned IPs.</p> </li> <li> <p>Troubleshooting Example:</p> <ul> <li>If no IP is assigned, check your DHCP configuration or static IP settings.</li> </ul> </li> </ul> <ul> <li>Usage: Similar to <code>ip addr</code> but older.   <pre><code>ifconfig\n</code></pre></li> </ul>"},{"location":"baseline/networking/networking_commands/#examining-network-connections","title":"Examining Network Connections","text":"netstatss <ul> <li>Usage: Display network connections, routing tables, and more.   <pre><code>netstat -an\n</code></pre></li> </ul> <ul> <li>Usage: Faster, modern replacement for <code>netstat</code>.   <pre><code>ss -tuln\n</code></pre> -Troubleshooting Example:<ul> <li>Use <code>ss</code> to identify open ports and active connections.</li> </ul> </li> </ul>"},{"location":"baseline/networking/networking_commands/#querying-dns","title":"Querying DNS","text":"nslookupdig <ul> <li>Usage: Query DNS for IP addresses.   <pre><code>nslookup google.com\n</code></pre></li> </ul> <ul> <li>Usage: Advanced DNS query tool.   <pre><code>dig google.com\n</code></pre></li> <li>Troubleshooting Example:<ul> <li>Use <code>nslookup</code> or <code>dig</code> to verify DNS resolution.</li> <li>If DNS fails, check your <code>/etc/resolv.conf</code> file or DNS server configuration.</li> </ul> </li> </ul>"},{"location":"baseline/networking/networking_concepts/","title":"Networking Concepts","text":"<p>Before diving into networking commands and tools, it's essential to understand the fundamental concepts that underpin all networking. These concepts provide the context for using tools effectively.</p>"},{"location":"baseline/networking/networking_concepts/#ip-addresses","title":"IP Addresses","text":"<ul> <li>IPv4: A 32-bit address (e.g., <code>192.168.1.1</code>) used to identify devices on a network.</li> <li>IPv6: A 128-bit address designed to replace IPv4, offering more unique addresses and better security.</li> </ul>"},{"location":"baseline/networking/networking_concepts/#why-it-matters","title":"Why It Matters","text":"<p>IP addresses are like the \"home addresses\" of devices on a network. They allow devices to find and communicate with each other.</p>"},{"location":"baseline/networking/networking_concepts/#subnets","title":"Subnets","text":"<ul> <li>Subnets divide a network into smaller segments to improve performance and security.</li> <li>Subnet Mask: Indicates which part of an IP address identifies the network vs. the host.</li> </ul>"},{"location":"baseline/networking/networking_concepts/#why-it-matters_1","title":"Why It Matters","text":"<p>Subnets optimize network traffic and enhance security by isolating sections of a network.</p>"},{"location":"baseline/networking/networking_concepts/#dns-domain-name-system","title":"DNS (Domain Name System)","text":"<ul> <li>Translates human-readable domain names (e.g., <code>google.com</code>) into IP addresses.</li> </ul>"},{"location":"baseline/networking/networking_concepts/#why-it-matters_2","title":"Why It Matters","text":"<p>Without DNS, you'd need to remember IP addresses for every website or service you want to access.</p>"},{"location":"baseline/networking/networking_concepts/#ports","title":"Ports","text":"<ul> <li>Ports are unique endpoints for specific types of network communication.</li> <li>HTTP: Port 80</li> <li>HTTPS: Port 443</li> <li>SSH: Port 22</li> </ul>"},{"location":"baseline/networking/networking_concepts/#why-it-matters_3","title":"Why It Matters","text":"<p>Understanding ports helps you identify and troubleshoot issues related to specific services.</p>"},{"location":"baseline/networking/networking_concepts/#protocols","title":"Protocols","text":"<ul> <li>TCP (Transmission Control Protocol): Reliable, connection-based communication.</li> <li>UDP (User Datagram Protocol): Faster, connectionless communication.</li> <li>HTTP/HTTPS: Protocols for web traffic.</li> </ul>"},{"location":"baseline/networking/networking_concepts/#why-it-matters_4","title":"Why It Matters","text":"<p>Protocols define how data is transmitted and received, making them critical for troubleshooting communication issues.</p>"},{"location":"baseline/networking/ssh_secure_shell/","title":"SSH (Secure Shell)","text":"<p>SSH is a secure protocol for remotely managing Linux systems. It allows you to execute commands on remote servers, transfer files, and manage systems securely.</p>"},{"location":"baseline/networking/ssh_secure_shell/#connecting-to-a-remote-machine","title":"Connecting to a Remote Machine","text":"<ul> <li>Command:   <pre><code>ssh user@remote-host\n</code></pre></li> <li>Replace <code>user</code> with your username and <code>remote-host</code> with the server's IP or domain.</li> </ul>"},{"location":"baseline/networking/ssh_secure_shell/#troubleshooting-connection-issues","title":"Troubleshooting Connection Issues:","text":"<ol> <li>Authentication Failures:</li> <li>Ensure the correct username and password.</li> <li> <p>Check for missing or incorrect SSH keys.</p> </li> <li> <p>Firewall or Port Issues:</p> <ul> <li>Verify that port 22 (default SSH) is open on the remote machine: <pre><code>ss -tuln | grep 22\n</code></pre></li> </ul> </li> </ol>"},{"location":"baseline/networking/ssh_secure_shell/#copying-files-securely","title":"Copying Files Securely","text":"scprsync <ul> <li>Command: <pre><code>scp file.txt user@remote-host:/path/to/destination\n</code></pre></li> </ul> <ul> <li>Command: <pre><code>rsync -av file.txt user@remote-host:/path/to/destination\n</code></pre></li> </ul>"},{"location":"baseline/networking/ssh_secure_shell/#troubleshooting-example","title":"Troubleshooting Example:","text":"<ul> <li>If file transfers fail, ensure <code>scp</code> or <code>rsync</code> is installed on both systems.</li> <li>Verify permissions on target directories.</li> </ul>"},{"location":"baseline/networking/ssh_secure_shell/#key-management","title":"Key Management","text":"Generate SSH KeysCopy Public Key to Remote Server <p>See the SSH Keys instructions on how to properly setup your SSH Keys.</p> <ul> <li>Command: <pre><code>ssh-keygen -t rsa\n</code></pre></li> </ul> <ul> <li>Command: <pre><code>ssh-copy-id user@remote-host\n</code></pre></li> </ul>"},{"location":"baseline/networking/ssh_secure_shell/#troubleshooting-example_1","title":"Troubleshooting Example:","text":"<ul> <li>If key authentication fails:</li> <li>Verify the public key is present in <code>~/.ssh/authorized_keys</code> on the remote server.</li> <li>Check permissions for <code>~/.ssh</code> (should be <code>700</code>) and <code>authorized_keys</code> (should be <code>600</code>).</li> </ul> <p>By mastering SSH, you'll be equipped to manage remote systems securely and efficiently.</p>"},{"location":"blog/2024/02/26/embrace-the-penguin/","title":"Embrace the Penguin \ud83d\udc27\ud83d\udcbb","text":"<p>Greeting fellow open-source adventurers and Linux enthusiasts! Welcome to the world where the Penguin reigns supreme. Here you will find topics ranging from traversing the land of open-source, command-line mastery, customization and general topics that unfold within the world of Linux.</p> <p>Here's to embracing the penguin, and the exciting Linux journey that lies ahead!</p>"},{"location":"blog/2024/02/26/embrace-the-penguin/#a-journey-into-the-wold-of-open-source-and-gnulinux","title":"A journey into the wold of Open-Source and GNU/Linux","text":"<p>There an countless resources both online and in books on shelves all around us, so why have I put this site together?  Well, mostly for my own reference. As I started my journey in GNU/Linux, and as I still travel, I find myself going back to references in notebooks, books on my self, online, etc to find the materials I need. If I do that, I bet there are many others that do the same thing. This is why I am building this hub.</p> <p>As noted in the intro, this site will host information of all types relating to GNU/Linux. Some will be in documentation format, others will be in blog post format.</p>"},{"location":"blog/2024/02/26/embrace-the-penguin/#breaking-free-from-the-shackles-of-proprietary-software","title":"Breaking Free from the shackles of Proprietary Software","text":"<p>While the information here will mostly cover GNU/Linux, it will include topics and software related to it and will delve into the open-source world as well.</p> <p>As you read on the home page, GNU/Linux is not just an Operating System but a movement that embraces transparency, rejection of vendor lock-ins and empowerment of users to shape their digital environment.</p> <p>GNU/Linux stands as a beacon of freedom and collaboration, this robust and versatile OS has become the heartbeat of servers, the foundation of embedded systems, and the playground for tech enthusiasts seeking a truly customizable computing experience.</p>"},{"location":"blog/2024/02/26/embrace-the-penguin/#command-line-mystique","title":"Command Line Mystique","text":"<p>For the uninitiated, the command line may seem like a mysterious gateway to a digital underworld where all sort of sorcery happens. We'll try our best to unravel it's secrets and empower you to command your machine with the freedom only GNU/Linux provides.</p>"},{"location":"blog/2024/02/26/embrace-the-penguin/#welcome-all","title":"Welcome All","text":"<p>Whether you're taking your first steps into the Linux ecosystem or you're a seasoned sysadmin, this site is your companion. From beginner-friendly tutorials to advanced tips and tricks, we aim to create a space where everyone can learn, share, and revel in the beauty of Linux.</p>"},{"location":"blog/2024/02/26/embrace-the-penguin/#the-journey-ahead","title":"The Journey Ahead","text":"<p>Together, we'll dive into the realms of distributions, explore the vast array of open-source software, and more. Linux is not just an operating system; it's a community-driven adventure waiting to unfold.</p> <p>This site is not just a collection of words; it's a gateway to the expansive universe of Linux. Your insights, questions, and experiences are the building blocks of this community. Let's embark on this Linux odyssey together, celebrating the freedom to tinker, the joy of discovery, and the camaraderie of like-minded penguin aficionados.</p>"},{"location":"blog/2025/05/18/why-linux-is-more-than-an-operating-system/","title":"Why Linux Is More Than an Operating System","text":"<p>This site isn\u2019t just about installing software or learning terminal commands\u2014it's about discovering why Linux matters. Whether you\u2019re a beginner exploring your first distro or a tech enthusiast curious about what makes Linux different, this journey is designed to open your mind, spark curiosity, and show you how Linux is more than just an operating system\u2014it\u2019s a whole new way of thinking about computing.</p>"},{"location":"blog/2025/05/18/why-linux-is-more-than-an-operating-system/#what-is-linux-really","title":"What Is Linux, Really?","text":"<p>At a glance, Linux might seem like just another operating system\u2014a replacement for Windows or macOS. But under the hood, Linux is so much more. It\u2019s:</p> <ul> <li>A kernel \u2014 the core piece of software that manages your hardware.</li> <li>A toolbox \u2014 filled with command-line utilities, scripts, and services.</li> <li>A culture \u2014 built on collaboration, transparency, and freedom.</li> <li>A foundation \u2014 powering everything from smartphones to supercomputers.</li> </ul> <p>Linux isn't a monolithic product with a central company\u2014it\u2019s an ecosystem of ideas, tools, and people.</p>"},{"location":"blog/2025/05/18/why-linux-is-more-than-an-operating-system/#the-linux-philosophy","title":"The Linux Philosophy","text":"<p>Linux draws heavily from the Unix tradition and the do-one-thing-well philosophy. It encourages:</p> <ul> <li>Modularity: Small tools that can be combined in endless ways.</li> <li>Transparency: You can inspect, modify, and understand your system.</li> <li>Control: You\u2019re not locked into defaults or forced updates.</li> <li>**Empowermen**t: You can break your system\u2014but that\u2019s often how you learn.</li> </ul> <p>It's not about having flashy GUIs or automation at every turn (though those exist); it's about understanding your computer and being in the driver\u2019s seat.</p>"},{"location":"blog/2025/05/18/why-linux-is-more-than-an-operating-system/#more-than-software-a-movement","title":"More Than Software: A Movement","text":"<p>Linux is free and open source\u2014not just free as in cost, but free as in freedom. That means:</p> <ul> <li>You can use it for any purpose.</li> <li>You can view and change the source code.</li> <li>You can share it with anyone.</li> <li>You can contribute to making it better.</li> </ul> <p>This isn\u2019t just a software license\u2014it\u2019s a philosophy that puts you in charge. It\u2019s why so many people say Linux helped them fall in love with computing again.</p>"},{"location":"blog/2025/05/18/why-linux-is-more-than-an-operating-system/#linux-in-the-real-world","title":"Linux in the Real World","text":"<p>It might surprise you to learn how much Linux impacts your daily life. It runs:</p> <ul> <li>Most of the world\u2019s web servers</li> <li>The Android OS on your phone</li> <li>Routers, smart TVs, and appliances</li> <li>NASA, Tesla, and the New York Stock Exchange</li> <li>The backend of Facebook, Google, and Amazon</li> </ul> <p>When you learn Linux, you're learning the foundation of modern infrastructure.</p> <p>Linux isn\u2019t just a system you use. It\u2019s a system you grow with.</p> <p>Whether you want to:</p> <ul> <li>Customize your desktop</li> <li>Self-host your own services</li> <li>Understand how computers really work</li> <li>Or join a global community of creators and problem-solvers...</li> </ul> <p>Linux gives you the freedom to explore, fail, fix, and master.</p>"},{"location":"blog/2025/04/18/why-choose-linux-over-macos-or-windows/","title":"Why Choose Linux Over macOS or Windows?","text":"<p>When it comes to operating systems, macOS and Windows are often the first choices that come to mind. They are polished, user-friendly, and come pre-installed on most computers. However, there\u2019s a third contender that has been quietly powering everything from supercomputers to smartphones: Linux.</p> <p>But why should you choose Linux over macOS or Windows? Let\u2019s dive into three key reasons: freedom, cost, and customization.</p>"},{"location":"blog/2025/04/18/why-choose-linux-over-macos-or-windows/#1-freedom-take-control-of-your-computing-experience","title":"1. Freedom: Take Control of Your Computing Experience","text":"<p>One of Linux's biggest advantages is the freedom it offers. Unlike macOS and Windows, Linux is open-source software, meaning anyone can view, modify, and distribute its code. This freedom translates into several benefits for users:</p> <ul> <li>No Vendor Lock-In: You're not tied to Apple or Microsoft\u2019s ecosystems. You\u2019re free to choose from hundreds of Linux distributions (distros) like Ubuntu, Fedora, and Arch Linux, each tailored to different needs.</li> <li>Transparency: With open-source code, you can see exactly how the operating system works. This is particularly important for privacy-conscious users, as Linux doesn\u2019t include hidden telemetry or invasive data collection.</li> <li>Community-Driven Development: Linux is built and maintained by a passionate community of developers and users. This means quicker updates, more innovation, and a focus on user needs rather than corporate profits.</li> </ul>"},{"location":"blog/2025/04/18/why-choose-linux-over-macos-or-windows/#2-cost-say-goodbye-to-licensing-fees","title":"2. Cost: Say Goodbye to Licensing Fees","text":"<p>Let\u2019s talk money. Both macOS and Windows come with significant costs:</p> <ul> <li>Hidden Costs of macOS: While macOS itself is \u201cfree\u201d with Apple hardware, the premium price of that hardware is anything but. Want to upgrade your MacBook? Be prepared to pay a small fortune.</li> <li>Windows Licensing Fees: Purchasing Windows for a custom-built PC or upgrading from an older version can cost upwards of $100 or more.</li> </ul> <p>Linux, on the other hand, is free. Yes, completely free. You can download a Linux distro, install it on as many devices as you want, and never pay a dime. This makes Linux an excellent choice for:</p> <ul> <li>Students and hobbyists on a budget.</li> <li>Organizations looking to reduce IT costs.</li> <li>Breathing new life into older hardware without additional expenses.</li> </ul>"},{"location":"blog/2025/04/18/why-choose-linux-over-macos-or-windows/#3-customization-make-your-os-truly-yours","title":"3. Customization: Make Your OS Truly Yours","text":"<p>If you\u2019re someone who loves to tinker and tailor things to your liking, Linux is your playground. Unlike macOS and Windows, which have rigid user interfaces and limited customization options, Linux offers unparalleled flexibility:</p> <ul> <li>Choose Your Desktop Environment: From the sleek and modern GNOME to the highly customizable KDE Plasma or lightweight XFCE, you can pick a desktop environment that suits your aesthetic and workflow.</li> <li>Modify Everything: Want to change how your taskbar works? Add a new feature to your file manager? With Linux, you can tweak nearly every aspect of the system.</li> <li>Themes and Appearance: Linux distros often come with an array of themes, icons, and widgets to personalize your desktop. You can even make Linux look like macOS or Windows if you want!</li> </ul> <p>This level of customization ensures that Linux can be adapted to fit your exact needs, whether you\u2019re a gamer, developer, creative professional, or casual user.</p>"},{"location":"blog/2025/04/18/why-choose-linux-over-macos-or-windows/#the-power-of-choice","title":"The Power of Choice","text":"<p>Choosing Linux over macOS or Windows boils down to empowerment. Linux gives you the freedom to control your computing experience, the cost-efficiency of free software, and the ability to customize your system to your heart\u2019s content. It\u2019s not just an operating system; it\u2019s a philosophy of openness, collaboration, and choice.</p> <p>So, why not give Linux a try? Whether you\u2019re reviving an old laptop, building a custom PC, or exploring open-source software for the first time, Linux has something to offer everyone.</p>"},{"location":"contribute/admonitions/","title":"Admonitions","text":""},{"location":"contribute/admonitions/#supported-types","title":"Supported types","text":"<p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Abstract</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Info</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Tip</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Success</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Question</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Warning</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Failure</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Danger</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Bug</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Example</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Quote</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"onboarding/choosing_distros/","title":"Choosing a Distro","text":"<p>Linux distributions, commonly referred to as \u201cdistros,\u201d are different flavors of the Linux operating system. Each distro shares the same core (the Linux kernel) but bundles it with different software, interfaces, and philosophies. Choosing the right one can feel daunting, but don\u2019t worry \u2014 you\u2019re not expected to know everything from day one.</p> <p>This guide is designed to help you pick a distro based on your experience level, hardware, personal preferences, and use cases. Whether you're a beginner, a tinkerer, or a gamer, there's a distro out there for you.</p>"},{"location":"onboarding/choosing_distros/#things-to-consider-when-choosing-a-distro","title":"Things to Consider When Choosing a Distro","text":"<p>When choosing a Linux distribution, it's important to consider several factors that can help determine the best fit for your needs. Here are some additional details to consider:</p> <ul> <li>Experience Level<ul> <li>New to Linux? Start with user-friendly options that work well out of the box.</li> <li>Intermediate or want to learn? Look for distros that offer flexibility and documentation.</li> <li>Advanced? Choose something minimalist or bleeding-edge for full control.</li> </ul> </li> <li>System Hardware<ul> <li>Have an older or low-powered device? Choose a lightweight distro.</li> <li>Gaming or creative work? Look for hardware acceleration, driver support, and performance tweaks.</li> </ul> </li> <li>Ease of Use vs. Customization<ul> <li>Some distros \u201cjust work\u201d with a polished experience.</li> <li>Others are minimal and allow you to build your system piece by piece.</li> </ul> </li> <li>Software &amp; Support<ul> <li>Consider the size of the software repository and the strength of the community.</li> <li>Well-documented distros with active forums are great for beginners.</li> </ul> </li> <li>Stability vs. Latest Features<ul> <li>Stable distros (like Ubuntu LTS or Debian Stable) are ideal for reliability.</li> <li>Rolling-release distros (like Arch or openSUSE Tumbleweed) offer the latest software, with more frequent updates.</li> </ul> </li> <li>Documentation and Community Support<ul> <li>Consider the availability of documentation, user guides, and community support resources.</li> <li>A strong and active user community can provide valuable assistance, troubleshooting help, and access to forums or online communities where you can learn from other users' experiences.</li> </ul> </li> <li>Security and Updates<ul> <li>Look into the distribution's approach to security and updates.</li> <li>Consider the frequency and reliability of security patches, as well as the distribution's update management system.</li> <li>Some distributions emphasize security and provide regular updates, while others may have a more relaxed approach.</li> </ul> </li> <li>Specialized Use Cases<ul> <li>Evaluate if the distribution caters to your specific use case.</li> <li>Some distributions, like Kali Linux, focus on penetration testing and cybersecurity, while others, like Ubuntu Studio, are tailored for multimedia production.</li> <li>If you have specific needs, such as gaming or server deployment, consider distributions that excel in those areas.</li> </ul> </li> <li>Personal Preference<ul> <li>Ultimately, personal preference plays a significant role.</li> <li>Experiment with different distributions by running live versions or virtual machines to get a feel for their user interface, software availability, and overall user experience.</li> <li>Choose a distribution that aligns with your preferences, workflow, and goals.</li> </ul> </li> </ul> <p>Remember that you can also dual-boot or try multiple distributions before settling on one. Linux distributions offer flexibility, and it's possible to switch between them or even have multiple distributions on different devices for various purposes. The Linux community encourages exploration, so don't hesitate to try different distributions and find the one that suits you best.</p>"},{"location":"onboarding/choosing_distros/#popular-linux-distributions-to-explore","title":"Popular Linux Distributions to Explore","text":"<p>Here\u2019s an overview of some beginner-friendly and widely respected Linux distributions:</p> <p>Note</p> <p>I use Pop!_OS for my machines.</p> Pop!_OSUbuntuLinux MintZorin OSelementary OSFedoraDebianArch LinuxopenSUSE <p>Pop!_OS is developed by System76 and optimized for productivity, creativity, and gaming. It features a clean GNOME-based interface with a built-in tiling window manager. It includes great out-of-the-box support for NVIDIA and AMD GPUs. Pop!_OS is ideal for users who want performance and polish without much setup.</p> <p>Ubuntu is one of the most widely used Linux distributions and a top recommendation for beginners. It\u2019s stable, well-supported, and easy to use. Ubuntu has a massive software ecosystem and strong community. LTS (Long-Term Support) versions are especially good for users who want security and updates without surprises.</p> <p>Linux Mint is based on Ubuntu but offers a more traditional desktop layout, which makes it especially comfortable for users coming from Windows. It includes multimedia codecs by default and offers multiple desktop environments \u2014 Cinnamon (most popular), MATE, and Xfce.</p> <p>Zorin OS is a polished and modern distro designed to look and feel like Windows or macOS. It\u2019s perfect for users switching from other operating systems. Zorin OS includes productivity apps and a sleek interface, making it a great out-of-the-box experience.</p> <p>elementary OS is a visually stunning distro that resembles macOS. It focuses on simplicity and privacy and is ideal for users who appreciate minimalist design and want a distraction-free desktop.</p> <p>Fedora is a cutting-edge distro sponsored by Red Hat. It features the latest Linux technologies and is ideal for developers and enthusiasts. Fedora\u2019s default GNOME environment is clean and modern, and it\u2019s well-suited for those who want to stay current without diving into manual system building.</p> <p>Debian is known for its rock-solid stability and free software principles. It\u2019s widely used in servers but also works well on desktops. Debian comes in stable, testing, and unstable branches, allowing users to choose their balance between stability and freshness.</p> <p>Arch Linux is a DIY distro focused on simplicity, transparency, and rolling releases. It doesn\u2019t come with a desktop environment or preinstalled software \u2014 you build your system your way. Arch is best for experienced users or those eager to learn Linux from the ground up. Its documentation, the Arch Wiki, is second to none.</p> <p>openSUSE comes in two versions: Leap (stable release) and Tumbleweed (rolling release). It\u2019s known for its YaST configuration tool, strong security features, and flexibility. openSUSE is great for both workstation and server use.</p>"},{"location":"onboarding/choosing_distros/#tips-for-trying-linux","title":"Tips for Trying Linux","text":"<ul> <li>Try a Live Session: Most distros can run from a USB stick without installing. You can try them out before making any changes to your computer.</li> <li>Use Virtual Machines: Tools like VirtualBox let you test multiple distros without rebooting or formatting your system.</li> <li>Don\u2019t Worry About Mistakes: The best way to learn Linux is by experimenting. Break things. Fix them. Learn. That\u2019s the Linux way.</li> </ul>"},{"location":"onboarding/choosing_distros/#still-not-sure","title":"Still Not Sure?","text":"<p>If you're new and want a safe, supported, and easy start, try one of these:</p> <ul> <li>Pop!_OS \u2013 for gaming or creative work out of the box.</li> <li>Linux Mint Cinnamon \u2013 for a classic desktop experience.</li> <li>Zorin OS Core \u2013 for a beautiful and intuitive layout.</li> <li>Ubuntu LTS \u2013 for long-term support and reliability.</li> </ul> <p>Once you're comfortable, you can explore more advanced options like Fedora, Arch, or even build your own custom setup.</p> <p>Linux is about freedom and choice \u2014 and finding what works for you. There\u2019s no single \u201cbest\u201d distro. Just the best one for your goals.</p> <p>Ready to start? Pick one from above, fire up a Live USB, and explore. You've got this!</p>"},{"location":"onboarding/file_manipulation/","title":"File Manipulation","text":""},{"location":"onboarding/file_manipulation/#introduction","title":"Introduction","text":"<p>In Linux, file manipulation commands are powerful tools that allow you to manage and manipulate files and directories efficiently. Understanding these commands is essential for navigating the file system, creating, copying, moving, and deleting files, as well as performing various other file-related operations. In this tutorial, we will explore some of the most commonly used file manipulation commands in Linux and provide practical examples to help you become proficient in working with files.</p>"},{"location":"onboarding/file_manipulation/#quick-intro-to-files-and-directories","title":"Quick intro to Files and Directories","text":"<p>Managing files and directories in Linux is an essential skill that allows you to organize, manipulate, and maintain your data effectively. In this guide, we will explore various file and directory management operations in Linux. These commands cover the basic operations for managing files and directories in Linux. By understanding and utilizing them effectively, you can efficiently organize, manipulate, and maintain your data. Experiment with these commands on your Linux system to become proficient in file and directory management, allowing you to streamline your workflows and maintain a well-structured file system.</p> Listing Files and DirectoriesCreating and RemovingCopying and MovingViewing and Editing FilesManaging PermissionsFinding Files and renamingNavigating the File System <ul> <li><code>ls</code>: List files and directories in the current directory.</li> <li><code>ls -l</code>: List files and directories in long format, providing detailed information such as permissions, ownership, size, and modification time.</li> <li><code>ls -a</code>: List all files and directories, including hidden files that start with a dot (<code>.</code>)</li> </ul> <ul> <li><code>touch</code>: Create an empty file or update the access and modification timestamps of an existing file.<ul> <li>Example: <code>touch filename</code></li> </ul> </li> <li><code>mkdir</code>: Create a new directory.<ul> <li>Example: <code>mkdir directoryname</code></li> </ul> </li> <li><code>rm</code>: Remove files.<ul> <li>Example: <code>rm filename</code></li> </ul> </li> <li><code>rmdir</code>: Remove an empty directory.<ul> <li>Example: <code>rmdir directoryname</code></li> </ul> </li> <li><code>rm -r</code>: Remove directories and their contents recursively.<ul> <li>Example: <code>rm -r directoryname</code></li> </ul> </li> </ul> <ul> <li><code>cp</code>: Copy files and directories.<ul> <li>Example: <code>cp source_file destination</code></li> </ul> </li> <li><code>cp -r</code>: Copy directories recursively.<ul> <li>Example: <code>cp -r sourcedir destination</code></li> </ul> </li> <li><code>mv</code>: Move or rename files and directories.<ul> <li>Example: <code>mv source_file destination</code></li> </ul> </li> <li><code>mv</code>: Rename files and directories.<ul> <li>Example: <code>mv old_name new_name</code></li> </ul> </li> <li><code>rename</code>: Rename multiple files using regular expressions.<ul> <li>Example: <code>rename 's/old_pattern/new_pattern/' files</code></li> </ul> </li> </ul> <ul> <li><code>cat</code>: Display the content of a file.<ul> <li>Example: <code>cat filename</code></li> </ul> </li> <li><code>less</code>: View file content interactively, allowing scrolling and searching.<ul> <li>Example: <code>less filename</code></li> </ul> </li> <li><code>nano</code>: A simple command-line text editor for editing files.<ul> <li>Example: <code>nano filename</code></li> </ul> </li> </ul> <ul> <li><code>chmod</code>: Change the permissions of a file or directory.<ul> <li>Example: <code>chmod permissions filename</code></li> </ul> </li> <li><code>chown</code>: Change the ownership of a file or directory.<ul> <li>Example: <code>chown user:group filename</code></li> </ul> </li> </ul> <ul> <li><code>find</code>: Search for files and directories based on various criteria.<ul> <li>Example: <code>find /path/to/search -name filename</code> </li> </ul> </li> </ul> <ul> <li><code>cd</code>: Change directory. Use this command to navigate between directories.<ul> <li>Example: <code>cd /path/to/directory</code></li> </ul> </li> <li><code>pwd</code>: Print the current working directory. This command displays the full path of the current directory.<ul> <li>Example: <code>pwd</code></li> </ul> </li> <li><code>ls</code>: List files and directories in the current directory.<ul> <li>Example: <code>ls</code></li> </ul> </li> <li><code>ls -l</code>: List files and directories in long format, providing detailed information such as permissions, ownership, size, and modification time.<ul> <li>Example: <code>ls -l</code></li> </ul> </li> <li><code>ls -a</code>: List all files and directories, including hidden files that start with a dot (.)<ul> <li>Example: <code>ls -a</code></li> </ul> </li> </ul>"},{"location":"onboarding/file_manipulation/#file-compression-and-archiving","title":"File Compression and Archiving:","text":"<ul> <li><code>tar</code>: Create or extract tar archives.<ul> <li>Example: <code>tar -cvf archive.tar files</code> (create)<ul> <li>Example: <code>tar -xvf archive.tar</code> (extract)</li> </ul> </li> </ul> </li> <li><code>gzip</code>: Compress files using the gzip algorithm.<ul> <li>Example: <code>gzip filename</code> (compress)</li> <li>Example: <code>gzip -d filename.gz</code> (decompress)</li> </ul> </li> </ul>"},{"location":"onboarding/file_manipulation/#managing-symbolic-links","title":"Managing Symbolic Links:","text":"<ul> <li><code>ln</code>: Create symbolic links to files or directories.<ul> <li>Example: <code>ln -s source_file link_name</code></li> </ul> </li> <li><code>readlink</code>: Display the target of a symbolic link.<ul> <li>Example: <code>readlink link_name</code></li> </ul> </li> </ul>"},{"location":"onboarding/file_manipulation/#file-permissions-and-attributes","title":"File Permissions and Attributes:","text":"<ul> <li><code>stat</code>: Display detailed information about a file or directory, including permissions, ownership, size, and timestamps.<ul> <li>Example: <code>stat filename</code></li> </ul> </li> <li><code>chattr</code>: Change file attributes such as immutability or append-only.<ul> <li>Example: <code>chattr +i filename</code> (set immutable)</li> </ul> </li> </ul>"},{"location":"onboarding/file_manipulation/#conclusion","title":"Conclusion:","text":"<p>Mastering file manipulation commands in Linux is essential for effectively managing files and directories. The commands covered in this tutorial provide a solid foundation for navigating the file system, creating, copying, moving, and deleting files, as well as performing other file-related operations. Practice using these commands on your Linux system to enhance your proficiency and efficiency in working with files. With time and experience, you will become adept at manipulating files and directories, enabling you to streamline your workflows and effetively manage your data.</p>"},{"location":"onboarding/file_structure/","title":"Filestructure","text":""},{"location":"onboarding/file_structure/#the-root-directory","title":"The Root Directory","text":"<p>The root directory (<code>/</code>) is the top-level directory in the file system hierarchy. It is the starting point from which all other directories and files in the system branch out. Here's a closer look at the root directory and its significance in the Linux file system:</p> <ul> <li>System Foundation     The root directory forms the foundation of the entire file system. It acts as the parent directory for all other directories and files, serving as the root of the directory tree. Every file and directory on the system can be traced back to the root directory through a series of paths.</li> <li>Absolute Path Reference     In Linux, file and directory paths are specified using absolute or relative paths. Absolute paths start from the root directory, providing a complete reference to a file or directory. For example, \"<code>/home/user/Documents/file.txt</code>\" specifies the file \"<code>file.txt</code>\" located within the \"Documents\" directory in the home directory of the user.</li> <li>File System Mount Points     The root directory serves as the mount point for different file systems. In Linux, multiple file systems can be mounted within the root directory, creating a unified file system view. For instance, the root directory may contain separate file systems for the system's main partition, <code>/home</code>, <code>/var</code>, or any other mounted partitions.</li> <li>Separation of User Data and System Files     By convention, system files and directories reside within the root directory or its subdirectories. System-related directories such as <code>/bin</code>, <code>/etc</code>, <code>/lib</code>, <code>/sbin</code>, and <code>/usr</code> contain essential system files, executables, configuration files, libraries, and system administration utilities. On the other hand, user-specific data, settings, and directories are typically found within the /home directory.</li> <li>Privileges and System Security     The root directory is the only directory in the file system hierarchy that is accessible to all users. However, modifying or accessing system files within the root directory typically requires administrative privileges. The root user (superuser or administrator) has complete control over the entire file system, enabling system-wide configuration, software installation, and maintenance tasks.</li> <li>File System Organization Standards     The root directory adheres to the Filesystem Hierarchy Standard (FHS) or Linux Standard Base (LSB) guidelines, which provide a standardized structure for file systems across different Linux distributions. These standards define the expected locations of system files, configuration files, libraries, binaries, and other components within the root directory.</li> </ul> <p>Understanding the significance of the root directory is crucial for navigating the Linux file system, locating system files and directories, and understanding the structure of the overall directory tree. The root directory serves as the starting point for accessing and managing all other files and directories in the system, making it a fundamental aspect of Linux's file system organization.</p>"},{"location":"onboarding/filesystem_navigation/","title":"Filesystem Navigation","text":"<p>Navigating the file system is a fundamental skill for any Linux user. Understanding how to efficiently move between directories and locate files and directories is crucial for effective system management and everyday tasks. In this comprehensive tutorial, we will explore the various commands and techniques that will empower you to navigate the Linux file system with ease.</p> <ul> <li>Understanding the File System Hierarchy:<ul> <li>The root directory (<code>/</code>): At the top of the file system hierarchy, the root directory serves as the starting point for all paths in Linux.</li> <li>Directories (Folders): Directories are containers for organizing files and other directories. They can be nested to create a hierarchical structure.</li> <li>Files: Files store data, including text, documents, programs, and more. They exist within directories.</li> </ul> </li> <li>Essential Commands for Navigating the File System:<ul> <li>cd (Change Directory):<ul> <li>Usage: <code>cd [directory]</code></li> <li>Description: The <code>cd</code> command allows you to change your current working directory to the specified directory.</li> <li>Examples:<ul> <li><code>cd /path/to/directory</code>: Changes the directory to the specified absolute path.</li> <li><code>cd ..</code>: Moves one level up to the parent directory.</li> </ul> </li> <li><code>cd</code>: Changes to the user's home directory.</li> </ul> </li> </ul> </li> <li>pwd (Print Working Directory):<ul> <li>Usage: <code>pwd</code></li> <li>Description: The <code>pwd</code> command displays the absolute path of your current working directory.</li> </ul> </li> <li>ls (List):         - Usage: <code>ls [options] [directory]</code>         - Description: The <code>ls</code> command lists the files and directories in the current directory.         - Examples:             - <code>ls</code>: Lists the files and directories in the current directory.             - <code>ls -l</code>: Displays a detailed list view, including permissions, ownership, size, and timestamps.             - <code>ls -a</code>: Shows all files and directories, including hidden files starting with a dot.</li> <li>Navigating the File System Efficiently:<ul> <li>Relative Paths: Instead of using the absolute path, you can navigate using relative paths, which are based on your current directory.</li> <li>Examples:<ul> <li><code>cd Documents</code>: Changes to the \"Documents\" directory within the current directory.</li> <li><code>cd ../Pictures</code>: Moves up one level and then enters the \"Pictures\" directory.</li> </ul> </li> <li>Tab Completion: Linux shells support tab completion, which allows you to quickly complete file and directory names by pressing the Tab key.</li> <li>Special Directories:</li> <li><code>.</code> (Current Directory): Represents the current working directory.</li> <li><code>..</code> (Parent Directory): Refers to the parent directory.</li> <li><code>~</code> (Tilde): Represents the user's home directory.</li> <li>History and Recall:</li> <li><code>history</code>: Displays a list of previously executed commands.</li> <li><code>!n</code>: Executes the command with the specified number (e.g., <code>!10</code> runs the 10<sup>th</sup> command in history).</li> <li>Using Wildcards:</li> <li>Wildcards are special characters that help match multiple files or directories based on patterns.</li> <li>Examples:<ul> <li><code>ls *.txt</code>: Lists all files ending with \".txt\".</li> <li><code>ls my_folder/*</code>: Displays the contents of the \"my_folder\" directory.</li> </ul> </li> </ul> </li> <li>Advanced File System Navigation:</li> <li>File System Links:<ul> <li>Symbolic Links: Symbolic links are special files that point to another file or directory.</li> <li><code>ln -s target link_name</code>: Creates a symbolic link to the target file or directory.</li> <li>Hard Links: Hard links allow multiple entries (names) to refer to the same file.</li> <li><code>ln target link_name</code>: Creates a hard link to the target file.</li> </ul> </li> </ul>"},{"location":"onboarding/fundamentals/","title":"Fundamentals","text":"<p>Let's introduce you to some essential terminology in the Linux ecosystem:</p> File System HierarchyPackage ManagementCommand-Line Interface (CLI)Shell PromptEnvironment Variables <p>Understanding the Linux File System Hierarchy is crucial for navigating and managing files and directories effectively. It provides a standardized structure that allows users and applications to locate and access resources in a consistent manner. Some key directories include:</p> <ul> <li><code>/</code>: The root directory is the top-level directory in the file system hierarchy. It serves as the starting point for the entire file system. All other directories and files are located under the root directory.</li> <li><code>/bin</code>: This directory contains essential binary executable files (commands) accessible to all users. Common system utilities and commands like <code>ls</code>, <code>cp</code>, <code>mv</code>, and <code>rm</code> are stored here.</li> <li><code>/etc</code>: This directory contains system-wide configuration files. It includes various configuration files for services, network settings, software defaults, and administrative tasks. Examples include <code>/etc/passwd</code> for user account information and <code>/etc/resolv.conf</code> for DNS configuration.</li> <li><code>/home</code>: This directory contains individual user home directories. Each user typically has a subdirectory under <code>/home</code> with their username, such as <code>/home/user1</code>. Users have read and write permissions within their respective home directories.</li> <li><code>/var</code>: This directory contains variable data that changes during system operation. It includes log files (<code>/var/log</code>), spool files (<code>/var/spool</code>), temporary files (<code>/var/tmp</code>), and other files that may grow or change in size over time.</li> <li><code>/usr</code>: This directory holds user-related programs, libraries, and documentation. It is further divided into several subdirectories, including:<ul> <li><code>/usr/bin</code>: User binaries (executable files) that are not essential for system booting.</li> <li><code>/usr/lib</code>: Libraries used by programs in <code>/usr/bin</code>.</li> <li><code>/usr/include</code>: Header files used for software development.</li> <li><code>/usr/share</code>: Architecture-independent data shared across multiple packages.</li> <li><code>/usr/local</code>: Locally-installed programs and libraries specific to the system.</li> </ul> </li> <li><code>/tmp</code>: This directory is used for storing temporary files created by applications or users. Files in <code>/tmp</code> are typically deleted upon system reboot, but individual distributions may have specific policies for managing this directory.</li> <li><code>/dev</code>: This directory contains device files representing hardware devices connected to the system. These special files allow software to communicate with and control devices, such as hard drives (<code>/dev/sda</code>), USB devices (<code>/dev/usb</code>), or serial ports (<code>/dev/ttyS0</code>).</li> <li><code>/proc</code>: This directory is a virtual file system that provides information about running processes and system resources. It contains a hierarchy of numbered directories representing each process, and files within these directories provide details such as process status, memory usage, and system configuration.</li> </ul> <p>Package management is a crucial aspect of Linux systems that simplifies the installation, updating, and removal of software packages. It ensures that software installations are efficient, secure, and consistent across different distributions. Here are some key points to expand on the topic:</p> <ul> <li>Package Formats<ul> <li>Linux distributions use different package formats. Two common formats are:<ul> <li>Debian-based systems: These distributions, such as Debian, Ubuntu, and Linux Mint, use the Debian Package format (<code>.deb</code>). Packages include the software binaries, dependencies, and installation scripts.</li> <li>Red Hat-based systems: Distributions like Fedora, CentOS, and RHEL use the Red Hat Package Manager format (<code>.rpm</code>). RPM packages also contain software binaries, dependencies, and installation scripts.</li> </ul> </li> </ul> </li> <li>Package Repositories<ul> <li>Package repositories are online software repositories that store a collection of pre-compiled software packages. They serve as centralized sources for package discovery, download, and installation. Linux distributions provide default repositories, which contain a wide range of software packages maintained by the distribution's developers. Additionally, users can add third-party repositories to access additional software not available in the default repositories.</li> </ul> </li> <li>**Package Management Tools:<ul> <li>Linux distributions offer package management tools that facilitate package installation, updates, and removal. Some common package management tools are:<ul> <li>Debian-based systems: Advanced Package Tool (APT), which includes commands like <code>apt-get</code> and <code>apt</code>, as well as graphical front-ends like Synaptic and GNOME Software.</li> <li>Red Hat-based systems: Yellowdog Updater, Modified (YUM) and Dandified YUM (DNF) are commonly used. Commands include <code>yum</code> and <code>dnf</code>.</li> </ul> </li> </ul> </li> <li>Package Operations<ul> <li>Package management tools provide a set of operations for managing software packages, including:<ul> <li>Installation: Packages can be installed from repositories using the package management tool. The tool resolves dependencies, fetching and installing all required packages.</li> <li>Upgrades: The package management tool can update installed packages to their latest available versions, ensuring that software remains secure and up to date.</li> </ul> </li> <li>Removal: Packages can be easily removed, which uninstalls the associated software and frees up disk space. The package management tool handles the removal of dependent packages that are no longer needed.</li> </ul> </li> <li>Dependency Management<ul> <li>Package management tools automatically handle software dependencies. When installing a package, the tool checks for required libraries and other packages and installs them if necessary. This ensures that all dependencies are satisfied and the software can run properly.</li> </ul> </li> <li>Package Verification and Security<ul> <li>Package management systems implement security measures to ensure the authenticity and integrity of packages. Packages are digitally signed using cryptographic keys, allowing the package management tool to verify their authenticity before installation. This helps protect against tampering and ensures that packages come from trusted sources.</li> </ul> </li> <li>Package Building and Source Code<ul> <li>Linux distributions often provide mechanisms for building packages from source code. This allows users to customize and compile software to suit their specific needs. Tools like <code>make</code>, <code>configure</code>, and <code>checkinstall</code> assist in the compilation and creation of packages from source code.</li> </ul> </li> </ul> <p>Package management simplifies software installation and maintenance on Linux systems. It provides a standardized and efficient way to manage software packages, ensuring a streamlined and secure experience for users. With package management tools, users can easily discover, install, update, and remove software, making Linux systems flexible and adaptable to changing needs.</p> <p>The Command-Line Interface (CLI) is a powerful and flexible tool in Linux that allows users to interact with the operating system and execute commands through a text-based interface. Here are some key aspects to expand on when it comes to the CLI:</p> <ul> <li>Shell<ul> <li>The shell is the program that interprets and executes commands entered by the user. The most common shell in Linux is the Bourne Again SHell (BASH). Other shells include Zsh, Fish, and Csh. Each shell has its own features, syntax, and customization options.</li> </ul> </li> <li>Command Syntax<ul> <li>Commands in the CLI have a specific syntax. Typically, a command consists of the command name followed by options and arguments. Options (also known as flags or switches) modify the behavior of the command, while arguments provide inputs or specify targets for the command to act upon. Commands can be combined together using pipes (<code>|</code>) or redirected using input/output redirection operators (<code>&gt;</code>, <code>&gt;&gt;</code>, <code>&lt;</code>, <code>|</code>).</li> </ul> </li> <li>Built-in Commands and External Programs<ul> <li>The CLI provides both built-in commands and external programs. Built-in commands are part of the shell itself and are executed directly without the need for a separate program. Examples of built-in commands include <code>cd</code> (change directory), <code>echo</code> (print text), and <code>alias</code> (create command shortcuts). External programs are standalone executables installed on the system and can be invoked from the command line.</li> </ul> </li> <li>Path and Environment Variables<ul> <li>The CLI uses the concept of paths and environment variables. The PATH variable is a list of directories that the system searches for executable files. When a command is entered, the shell looks for the executable in the directories listed in the PATH variable. Environment variables store information that can be accessed by programs and scripts. Common environment variables include <code>HOME</code> (user's home directory), <code>PATH</code> (executable search path), and <code>USER</code> (current username).</li> </ul> </li> <li>Tab Completion<ul> <li>Tab completion is a time-saving feature in the CLI. By pressing the Tab key, the shell automatically completes command names, file names, and directories based on what you have typed. It helps avoid typing errors and speeds up command entry.</li> </ul> </li> <li>Command History and Editing<ul> <li>The CLI keeps a history of previously entered commands. You can navigate through the command history using the arrow keys or use specific shortcuts to recall, modify, or reuse previous commands. Editors such as Emacs and Vi can be used for more advanced command-line editing.</li> </ul> </li> <li>Shell Scripting<ul> <li>The CLI is widely used for shell scripting, which involves writing scripts that automate tasks and combine multiple commands into a single file. Shell scripts can be executed as a series of commands or as standalone programs.</li> </ul> </li> <li>System Administration and Automation<ul> <li>The CLI is particularly useful for system administration tasks and automation. It provides powerful tools for managing files, configuring network settings, installing software, monitoring system performance, and much more. Many system administration tasks can be scripted and executed from the command line, making it efficient for managing and maintaining Linux systems.</li> </ul> </li> </ul> <p>The command-line interface offers extensive control and flexibility to Linux users. It allows for precise system control, efficient task execution, and the ability to automate complex operations. Becoming familiar with the CLI enables users to take full advantage of Linux's capabilities and perform a wide range of tasks efficiently.</p> <p>The shell prompt is a textual indicator displayed by the command-line interface (CLI) to signal that the shell is ready to receive user commands. It provides information about the system's current state and can be customized to meet individual preferences. Here are some aspects to expand on when discussing the shell prompt:</p> <ul> <li>Structure of the Shell Prompt<ul> <li>The shell prompt typically appears as a line of text on the command line, usually at the beginning of each new line. It consists of several components, which may include:<ul> <li>Username: The username of the currently logged-in user.</li> <li>Hostname: The name of the computer or system on which the shell is running.</li> <li>Current Working Directory: The path of the directory in which the user is currently located.</li> <li>Privilege Level: A symbol (e.g., <code>$</code> or <code>#</code>) that indicates the user's privilege level. A regular user typically has a <code>$</code> prompt, while the root user (superuser) has a <code>#</code> prompt.</li> </ul> </li> </ul> </li> <li>Customization Options<ul> <li>The shell prompt can be customized to suit personal preferences or display additional information. Users can modify the prompt's appearance, add colors or special characters, and include additional information relevant to their workflow. Customization is typically achieved by configuring environment variables, such as <code>PS1</code> (for BASH) or <code>PROMPT</code> (for Zsh), which control the prompt's format and content.</li> </ul> </li> <li>Displaying System Information<ul> <li>The shell prompt can display various system-related information to provide context and aid in navigation. For example:<ul> <li>Current Working Directory: Showing the full or abbreviated path of the current working directory helps users keep track of their location in the file system.</li> <li>Hostname: Displaying the hostname can be useful in a networked environment where multiple systems are involved.</li> <li>Git Branch: If the current directory is part of a Git repository, the prompt can show the active branch name or indicate the repository status.</li> </ul> </li> </ul> </li> <li>Dynamic Prompts<ul> <li>Some advanced shell prompts can be dynamically updated to provide real-time information. For instance:<ul> <li>Time and Date: The prompt can display the current time and date, keeping users informed without the need for executing additional commands.</li> <li>Command Execution Status: After running a command, the prompt can display the exit status of the command, indicating success (0) or failure (non-zero).</li> </ul> </li> </ul> </li> <li>Prompt Themes and Preconfigured Prompts<ul> <li>Users can choose from a variety of preconfigured prompt themes or templates to change the prompt's appearance. These themes often include color schemes, special symbols, and additional information, making the prompt visually appealing and informative. Popular shell prompt customization frameworks include Powerline, Oh My Zsh, and Starship.</li> </ul> </li> <li>Accessibility Considerations<ul> <li>Shell prompt customization can be valuable for users with visual impairments or color blindness. Choosing color schemes with sufficient contrast or including audible indicators in the prompt can enhance accessibility.</li> </ul> </li> </ul> <p>The shell prompt is more than just a visual element; it provides users with contextual information, helps navigate the file system, and can be tailored to individual preferences. By customizing the shell prompt, users can create a personalized and informative command-line experience that suits their workflow and enhances productivity.</p> <p>Environment variables are dynamic values that are part of the environment in which a process runs. They store information that can be accessed by programs, scripts, and the operating system itself. Here are some aspects to expand on when discussing environment variables:</p> <ul> <li>Purpose and Function<ul> <li>Environment variables serve various purposes, including:<ul> <li>Configuration: Environment variables store configuration settings that affect the behavior of software and applications. For example, the <code>PATH</code> variable specifies the directories to search for executable files.</li> <li>System Information: Environment variables provide information about the system, such as the current user (<code>USER</code>), the home directory (<code>HOME</code>), or the operating system (<code>OS</code>).</li> <li>Interprocess Communication: Environment variables enable communication between processes by sharing data. Processes can read environment variables to access shared values or configure their behavior based on specific variables.</li> </ul> </li> </ul> </li> <li>System and User Variables Environment variables can be system-wide or user-specific. System variables are set for the entire operating system and are available to all users. User variables are specific to each user and may override system variables with the same name.</li> <li>Commonly Used Environment Variables<ul> <li>There are numerous environment variables available in Linux systems. Here are some commonly used ones:<ul> <li><code>PATH</code>: Specifies the directories to search for executable files when a command is entered.</li> <li><code>HOME</code>: Indicates the user's home directory, where their personal files and settings are stored.</li> <li><code>USER</code> and USERNAME: Identify the currently logged-in user.</li> <li><code>SHELL</code>: Stores the path to the user's default shell.</li> <li><code>LANG</code> and <code>LC_*</code>: Control the language and localization settings for the system.</li> <li><code>PS1</code>: Defines the prompt string displayed by the shell prompt.</li> </ul> </li> </ul> </li> <li>Setting and Modifying Environment Variables<ul> <li>Environment variables can be set or modified using different methods, such as:<ul> <li>Shell Configuration Files: Environment variables can be defined in shell configuration files like <code>.zshrc</code>, <code>.bashrc</code> or <code>.profile</code>. Changes made to these files require a new shell session or re-sourcing the file for the changes to take effect.</li> <li>Command-Line Assignment: Variables can be set temporarily by assigning values directly in the command line. For example, <code>export VARIABLE=value</code> sets the value of the variable for the current session.</li> <li>Startup Scripts: System-wide environment variables can be set in startup scripts executed during boot, such as <code>/etc/profile</code> or scripts in <code>/etc/profile.d/</code> directory.</li> </ul> </li> </ul> </li> <li>Viewing Environment Variables<ul> <li>To view the current environment variables, the <code>env</code> command or <code>printenv</code> command can be used. These commands display a list of all environment variables and their values.</li> </ul> </li> <li>Using Environment Variables in Scripts<ul> <li>Environment variables are often used in scripts to access configuration values, control program behavior, or store temporary data. Scripts can read environment variables using the <code>$VARIABLE_NAME</code> syntax in shells like BASH.</li> </ul> </li> <li>Exporting Variables<ul> <li>Variables that need to be available to child processes need to be exported using the export command. This ensures that the variable is inherited by subsequent processes.</li> </ul> </li> </ul> <p>Environment variables are a powerful mechanism in Linux that enable flexible configuration, interprocess communication, and customization. Understanding how to set, modify, and utilize environment variables can enhance the functionality and flexibility of the system and its applications.</p> <p>Understanding these fundamental concepts will help you navigate the Linux file system, manage software packages, and interact with the command-line interface effectively. As you gain more experience, you'll discover additional terminology and commands specific to your chosen distribution and interests.</p>"},{"location":"onboarding/interface/","title":"Interface","text":"<p>Let's familiarize you with the basic desktop environment and user interface commonly found in Linux distributions.</p> <ul> <li>Desktop Environment<ul> <li>A desktop environment provides the graphical user interface (GUI) for interacting with the operating system. The most popular desktop environments in Linux include GNOME, KDE Plasma, Xfce, Cinnamon, and MATE. Each desktop environment offers a different look, feel, and set of features, but they typically include common elements such as a panel, menu, and system tray.</li> </ul> </li> <li>Panel or Taskbar<ul> <li>The panel, also known as a taskbar or dock, is a horizontal or vertical bar that runs along the edge of the screen. It usually contains a variety of icons and applets that provide quick access to commonly used applications, system settings, and notifications. The panel may also display the date and time, a system menu, and indicators for battery life, network connectivity, and sound volume.</li> </ul> </li> <li>Menu<ul> <li>The menu, often located on the left or top of the screen, provides access to applications, system settings, and various other features. Clicking on the menu button typically opens a hierarchical list of categories and subcategories, allowing you to navigate and launch applications installed on your system. Some desktop environments feature a search function within the menu to quickly locate specific applications.</li> </ul> </li> <li>Window Management<ul> <li>Linux desktop environments provide various window management features for organizing and controlling open applications. You can move, resize, maximize, minimize, and close windows using the provided window decorations, which are typically located at the top-right corner of each window. Some desktop environments offer additional features like virtual workspaces, which allow you to have multiple desktops for better organization and productivity.</li> </ul> </li> <li>File Manager<ul> <li>A file manager is an integral part of the desktop environment, providing a graphical interface for navigating and managing files and directories on your computer. It allows you to browse folders, create, delete, and rename files, and perform basic file operations such as copying, moving, and searching. File managers often include a sidebar or a directory tree for easy navigation and a preview pane for viewing file contents.</li> </ul> </li> <li>System Settings<ul> <li>The system settings control panel provides a centralized location for configuring various aspects of your Linux system. It allows you to customize desktop appearance, manage hardware devices, set up network connections, configure power and battery settings, manage user accounts, and perform system-level administrative tasks. The system settings panel is typically accessible through the main menu or a dedicated icon in the panel.</li> </ul> </li> <li>Notifications<ul> <li>Linux desktop environments feature a notification area or system tray that displays alerts, notifications, and status updates. These notifications can include information about software updates, incoming messages, battery status, network connectivity, and other system events. Clicking on a notification often opens a related application or provides options to take action.</li> </ul> </li> </ul> <p>Keep in mind that the specific layout, appearance, and functionality may vary slightly between different Linux distributions and desktop environments. Exploring the desktop environment and interacting with its various elements will help you become more familiar with the Linux user interface. Don't hesitate to experiment, customize settings, and discover additional features that can enhance your overall user experience.</p>"},{"location":"onboarding/intro/","title":"Intro to Linux","text":""},{"location":"onboarding/intro/#history-and-philosophy","title":"History and Philosophy","text":"<p>The history and philosophy behind Linux are closely intertwined, shaping the development and principles of the operating system. Here's an explanation of the key aspects:</p> <ul> <li>Origins and Development<ul> <li>Linux was born out of Linus Torvalds' desire to create an alternative to proprietary operating systems. Torvalds initially developed the Linux kernel as a hobby project, but its popularity grew rapidly as more people recognized its potential. Over the years, with the help of thousands of developers worldwide, the Linux kernel has evolved into a robust, feature-rich, and highly scalable component of the operating system.</li> </ul> </li> <li>Open Source and Collaboration<ul> <li>The open-source nature of Linux allows anyone to access, modify, and distribute its source code. This philosophy fosters collaboration and knowledge sharing among developers and users. It encourages transparency, enabling users to understand how the software works and verify its security. The open-source community contributes to Linux by submitting bug fixes, creating new features, and ensuring continuous improvement.</li> </ul> </li> <li>GNU Project and Free Software Foundation<ul> <li>The GNU Project, led by Richard Stallman, aimed to develop a free and open-source operating system. Although the GNU Project produced many critical software components, including compilers, editors, and utilities, it lacked a kernel. The Linux kernel, combined with the GNU software, created a complete operating system known as GNU/Linux. The Free Software Foundation (FSF), founded by Stallman, advocates for the principles of free software and supports the development and promotion of GNU/Linux.</li> </ul> </li> <li>Stability, Security, and Reliability<ul> <li>Linux is renowned for its stability, security, and reliability. Its modular architecture allows for efficient use of system resources, making it highly stable even under heavy workloads. Linux's security features, such as user permissions and isolation, protect against unauthorized access and malicious software. The robustness of Linux is evident in its wide adoption in critical systems, servers, and high-performance computing environments.</li> </ul> </li> <li>Diversity of Distributions<ul> <li>Linux distributions offer a wide range of choices to cater to different user needs and preferences. Each distribution packages the Linux kernel with a specific set of software packages, configurations, and desktop environments. This diversity ensures that users can find a distribution that best suits their requirements, whether it's a beginner-friendly desktop-focused distro like Ubuntu or a minimalistic and customizable distribution like Arch Linux.</li> </ul> </li> <li>Freedom and User Empowerment<ul> <li>Linux embodies the principles of software freedom, empowering users with control over their computing environments. Users have the freedom to use, study, modify, and distribute the software, allowing them to tailor Linux to their specific needs. This freedom encourages innovation, fosters a culture of self-sufficiency, and avoids dependency on single vendors or proprietary solutions. Users can modify the source code, create custom distributions, or contribute to the development of Linux itself.</li> </ul> </li> <li>Community and Collaboration<ul> <li>The Linux community is a vibrant and diverse ecosystem of developers, enthusiasts, and users who collaborate to improve and promote Linux. Online forums, mailing lists, and community-driven projects facilitate knowledge exchange, problem-solving, and collective development efforts. Linux enthusiasts contribute their expertise, share their experiences, and support others in the community. This collaborative spirit has been crucial in the success and widespread adoption of Linux.</li> </ul> </li> </ul> <p>The combination of its origins, open-source nature, stability, security, diversity, and user empowerment has made Linux a powerful force in the computing world. Linux's philosophy fosters a community-driven approach to software development, emphasizing transparency, collaboration, and the freedom to explore and customize the operating system according to individual needs.</p>"},{"location":"onboarding/intro/#benefits-of-using-linux","title":"Benefits of using Linux","text":"<p>Using Linux as an operating system offers numerous benefits across various aspects of computing. Here are some key advantages:</p> <ul> <li>Stability and Reliability    Linux is known for its stability and reliability, making it an excellent choice for critical systems and servers. Its robust architecture and efficient resource management minimize crashes, slowdowns, and system errors, ensuring consistent performance over extended periods of time.</li> <li>Security    Linux is renowned for its strong security features. Its open-source nature allows the community to constantly monitor and enhance its security measures. Linux benefits from prompt security updates, fast vulnerability fixes, and a lower susceptibility to malware and viruses compared to other operating systems.</li> <li>Customization and Flexibility    Linux offers extensive customization options, allowing users to tailor their computing environment to suit their specific needs. With a wide range of desktop environments, themes, and software packages available, users can personalize their Linux distribution to create a personalized and efficient workspace.</li> <li>Open Source and Freedom    Linux's open-source nature promotes transparency, collaboration, and user empowerment. The availability of source code enables users to understand how the system works, modify it to suit their requirements, and contribute to its improvement. This openness fosters innovation, avoids vendor lock-in, and ensures the longevity of the software.</li> <li>Cost-Effectiveness    Linux is typically free to use, which significantly reduces software costs. Users can download, install, and distribute Linux distributions without licensing fees. Additionally, Linux runs efficiently on older hardware, enabling users to extend the lifespan of their devices and save money on hardware upgrades.</li> <li>Vast Software Ecosystem    Linux boasts a vast and growing software ecosystem. Thousands of open-source applications are readily available through package managers, providing users with a wide range of productivity tools, multimedia software, development environments, and server applications. Many popular software platforms, such as web servers, databases, and content management systems, are optimized for Linux.</li> <li>Compatibility and Portability    Linux supports a wide range of hardware architectures, making it compatible with various devices, from embedded systems to supercomputers. It can be easily installed and configured on different platforms, offering seamless transitions between systems and ensuring cross-compatibility across diverse computing environments.</li> <li>Community and Support    The Linux community is a thriving and supportive ecosystem of users, developers, and enthusiasts. Active online forums, mailing lists, and social media groups provide a wealth of knowledge, troubleshooting assistance, and guidance for Linux users. The community-driven nature of Linux ensures that users have access to a vast network of resources and support.</li> <li>Education and Learning    Linux serves as an excellent educational tool for learning about operating systems, programming, and computer science. Its open nature allows users to delve into the underlying mechanisms of the system, experiment with coding, and gain a deeper understanding of computing concepts.</li> <li>Environmentally Friendly     Linux's efficiency, lightweight design, and ability to run on older hardware contribute to its environmental friendliness. It allows users to repurpose older devices, reduces electronic waste, and promotes sustainable computing practices.</li> </ul> <p>These benefits make Linux an attractive choice for individuals, organizations, and industries seeking stability, security, flexibility, cost-effectiveness, and community-driven collaboration in their computing environments.</p>"},{"location":"setup/computer_setup/","title":"Linux Onboarding Guide","text":"<p>This document provides step-by-step instructions for setting up a Linux workstation with essential developer tools and customizations, tailored for both Debian-based and Fedora-based systems.</p>"},{"location":"setup/computer_setup/#system-update","title":"System Update","text":"<p>Always start with a full system update.</p> Debian-basedFedora-based <pre><code>sudo apt update &amp;&amp; sudo apt upgrade -y\n</code></pre> <pre><code>sudo dnf update -y\n</code></pre>"},{"location":"setup/computer_setup/#install-homebrew-linuxbrew","title":"Install Homebrew (Linuxbrew)","text":"<p>Homebrew is a popular package manager. It's optional but very useful.</p> <p>Install dependencies:</p> <ul> <li><code>build-essential</code> \u2013 Installs compilers and tools for building software (like <code>gcc</code>, <code>make</code>).</li> <li><code>procps</code> \u2013 Provides system utilities like <code>ps</code>, <code>top</code>, <code>kill</code>, etc.</li> <li><code>curl</code> \u2013 Transfers data from or to a server using URL syntax (<code>HTTP</code>, <code>FTP</code>, etc).</li> <li><code>file</code> \u2013 Detects file types based on content, not extension.</li> <li><code>git</code> \u2013 Distributed version control system for tracking code changes.</li> </ul> Debian-basedFedora-basedInstall Homebrew <pre><code>sudo apt install build-essential procps curl file git -y\n</code></pre> <pre><code>sudo dnf groupinstall \"Development Tools\" -y &amp;&amp; sudo dnf install procps-ng curl file git -y\n</code></pre> <p><pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> - Add Homebrew to your shell profile (this will be prompted at the end of the install): <pre><code>echo 'eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"' &gt;&gt; ~/.profile\neval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"\n</code></pre> - Test it: <pre><code>brew doctor\n</code></pre></p>"},{"location":"setup/computer_setup/#install-zsh","title":"Install Zsh","text":"<p>Zsh is a more powerful alternative to bash.</p> Debian-basedFedora-based <pre><code>sudo apt install zsh -y\n</code></pre> <pre><code>sudo dnf install zsh -y\n</code></pre> <p>Then change your default shell:</p> <pre><code>chsh -s $(which zsh)\n</code></pre> <p>Log out and back in to use Zsh.</p>"},{"location":"setup/computer_setup/#install-oh-my-zsh","title":"Install Oh My Zsh","text":"<p>A framework for managing your Zsh configuration.</p> <pre><code>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n</code></pre>"},{"location":"setup/computer_setup/#install-powerlevel10k-theme","title":"Install Powerlevel10k Theme","text":"<p>Powerlevel10k is a fast, stylish Zsh theme.</p> <ul> <li>Clone the theme: <pre><code>git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\n</code></pre></li> <li>Set the theme in your <code>~/.zshrc</code>: <pre><code>ZSH_THEME=\"powerlevel10k/powerlevel10k\"\n</code></pre></li> <li>Then reload Zsh: <pre><code>source ~/.zshrc\n</code></pre></li> <li>When prompted, go through the Powerlevel10k configuration wizard.</li> </ul>"},{"location":"setup/computer_setup/#optional-nice-to-haves","title":"Optional Nice-to-Haves","text":"<p>Here are some other useful tools and utilities you might want:</p> <ul> <li><code>bat</code> \u2013 A <code>cat</code> clone with syntax highlighting and Git integration.</li> <li><code>exa</code> \u2013 A modern replacement for <code>ls</code> with more features and colors.</li> <li><code>fzf</code> \u2013 A fast fuzzy finder for searching files, history, etc.</li> <li><code>ripgrep</code> \u2013 A super-fast recursive search tool, like <code>grep</code> but better.</li> <li><code>neovim</code> \u2013 A modern, extensible version of the Vim text editor.</li> </ul> Debian-basedFedora-basedVia Homebrew <pre><code>sudo apt install bat exa fzf ripgrep neovim -y\n</code></pre> <pre><code>sudo dnf install bat exa fzf ripgrep neovim -y\n</code></pre> <ul> <li>works the same on both distros <pre><code>brew install bat exa fzf ripgrep neovim\n</code></pre></li> </ul>"},{"location":"setup/computer_setup/#reboot-optional","title":"Reboot (optional)","text":"<p>Some changes (like default shell) take effect cleanly after a reboot:</p> <pre><code>sudo reboot\n</code></pre> <p>You're now set up with a modern, powerful Linux terminal environment!</p>"},{"location":"setup/python/","title":"Installing Python on Linux","text":"<p>This guide walks you through installing Python on a Linux system using the Homebrew package manager and explains how to create and manage isolated project environments using Python's built-in <code>venv</code> module.</p>"},{"location":"setup/python/#why-homebrew-on-linux","title":"Why Homebrew on Linux?","text":"<p>While most Linux distributions have their own package managers (like <code>apt</code> for Debian/Ubuntu, <code>dnf</code>/<code>yum</code> for Fedora/CentOS), Homebrew (often called Linuxbrew when on Linux) offers some advantages:</p> <ul> <li>User-space Installation: Installs packages in your home directory, avoiding the need for <code>sudo</code> for package management after the initial Homebrew install.</li> <li>Up-to-date Packages: Often provides newer versions of software than might be available in default distribution repositories.</li> <li>Consistent Environment: Useful if you also work on macOS, as it uses the same commands.</li> </ul>"},{"location":"setup/python/#why-virtual-environments","title":"Why Virtual Environments?","text":"<p>Python projects often depend on specific versions of external libraries. Installing these globally can lead to conflicts between projects requiring different versions of the same library. Virtual environments solve this by:</p> <ul> <li>Creating isolated environments for each project.</li> <li>Allowing you to install project-specific dependencies without affecting the global Python installation or other projects.</li> <li>Making projects self-contained and reproducible.</li> </ul>"},{"location":"setup/python/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Linux system.</li> <li>Basic familiarity with the Linux command line (terminal).</li> <li><code>curl</code>, <code>git</code>, and <code>build-essential</code> (or equivalent development tools for your distribution) installed. You can usually install these using your system's package manager:<ul> <li>Debian/Ubuntu/Pop!_OS: <pre><code>sudo apt update &amp;&amp; sudo apt install build-essential curl file git\n</code></pre></li> <li>Fedora/CentOS/RHEL: <pre><code>sudo dnf groupinstall \"Development Tools\" &amp;&amp; sudo dnf install curl file git\n</code></pre></li> </ul> </li> </ul>"},{"location":"setup/python/#install-homebrew-linuxbrew","title":"Install Homebrew (Linuxbrew)","text":"<ol> <li>Download and Run the Installer: Open your terminal and run the official installation script from the Homebrew website (<code>brew.sh</code>). <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></li> </ol> <p>Note</p> <ul> <li>Always check the official Homebrew website for the most current installation command, as it might change.</li> <li>The script will explain what it will do and prompt you for your password (for <code>sudo</code>) at certain points during the installation.</li> </ul> <ol> <li>Add Homebrew to your PATH: After the installation completes, the script will likely output instructions to add Homebrew to your system's PATH. This usually involves running a couple of commands similar to these (the exact commands will be provided by the installer output \u2013 use those!): <pre><code># Example commands - Follow the instructions from *your* installation!\necho 'eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"' &gt;&gt; ~/.zshrc\neval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"\n</code></pre><ul> <li>You might need to add this to <code>.bashrc</code>, <code>.zshrc</code>, or another shell configuration file depending on your shell and setup. The installer's output is the best guide.</li> <li>Close and reopen your terminal or run either  <code>source ~/.bashrc</code> or <code>source ~/.zshrc</code> (or the relevant config file) for the changes to take effect.</li> </ul> </li> <li>Verify Installation: Check that Homebrew is installed correctly. <pre><code>brew --version\nbrew doctor\n</code></pre> <code>brew doctor</code> will check for potential issues with your setup. Address any warnings if necessary.</li> </ol>"},{"location":"setup/python/#install-python-using-homebrew","title":"Install Python using Homebrew","text":"<ol> <li>Update Homebrew: Ensure Homebrew has the latest package information. <pre><code>brew update\n</code></pre></li> <li>Install Python: Use Homebrew to install the latest stable version of Python 3. <pre><code>brew install python\n</code></pre><ul> <li>Homebrew typically installs Python as <code>python3</code>.</li> </ul> </li> <li>Verify Python Installation: Check the installed Python version. <pre><code>python3 --version\n</code></pre></li> <li>This should output the version you just installed via Homebrew. You can also check its location: <pre><code>which python3\n</code></pre><ul> <li>This should point to a path within your Homebrew installation directory (e.g., <code>/home/linuxbrew/.linuxbrew/bin/python3</code> or similar).</li> </ul> </li> </ol> <p>Important</p> <ul> <li>Your system might still have a default Python installed (accessible via <code>python</code> or an older <code>python3</code>).</li> <li>Using <code>python3</code> after installing with Homebrew ensures you're using the Homebrew-managed version.</li> </ul>"},{"location":"setup/python/#creating-and-using-a-virtual-environment","title":"Creating and Using a Virtual Environment","text":"<p>Now that you have Python installed, let's create an isolated environment for a project.</p> <ol> <li>Navigate to Your Project Directory: Create a directory for your new project (if it doesn't exist) and change into it. <pre><code>mkdir my-python-project\ncd my-python-project\n</code></pre></li> <li>Create the Virtual Environment: Use the <code>venv</code> module included with Python 3. It's standard practice to name the environment directory <code>.venv</code>. The leading dot (<code>.</code>) makes it a hidden directory on Linux/macOS. <pre><code>python3 -m venv .venv\n</code></pre><ul> <li>This command creates a <code>.venv</code> directory containing a copy of the Python interpreter, the <code>pip</code> package manager, and other necessary files.</li> </ul> </li> <li>Activate the Virtual Environment: Before you can install packages into or run scripts using the virtual environment, you need to activate it. <pre><code>source .venv/bin/activate\n</code></pre><ul> <li>Once activated, your shell prompt will usually change to indicate the active environment, for example: <pre><code>(.venv) user@hostname:~/my-python-project$\n</code></pre></li> <li>Now, commands like <code>python</code> and <code>pip</code> will refer to the versions inside the <code>.venv</code> directory, not the global ones.</li> </ul> </li> <li>Install Packages: With the environment active, you can install packages using <code>pip</code>. They will be installed only within this environment. <pre><code># Example: Install the 'requests' library\npip install requests\n\n# Verify installation\npip list\n</code></pre><ul> <li><code>pip list</code> will show <code>requests</code> and its dependencies installed, but only when the <code>.venv</code> is active.</li> </ul> </li> <li>Work on Your Project: Create your Python scripts (e.g., <code>main.py</code>) within the <code>my-python-project</code> directory. When you run <code>python main.py</code>, it will use the Python interpreter and libraries from the active <code>.venv</code>.</li> <li>Deactivate the Virtual Environment: When you're finished working on the project, you can deactivate the environment. <pre><code>deactivate\n</code></pre><ul> <li>Your shell prompt will return to normal.</li> </ul> </li> </ol>"},{"location":"setup/python/#best-practices","title":"Best Practices","text":".gitignorerequirements.txt <p>Add your virtual environment directory (<code>.venv/</code>) to your project's <code>.gitignore</code> file. This prevents committing the large environment directory and its installed packages (which can be platform-specific) to your version control system (like Git).</p> <pre><code># .gitignore\n.venv/\n__pycache__/\n*.pyc\n</code></pre> <p>To share your project's dependencies with others or to easily recreate the environment, generate a <code>requirements.txt</code> file:</p> <ul> <li>While the virtual environment is active: <pre><code>pip freeze &gt; requirements.txt\n</code></pre></li> <li>Commit this <code>requirements.txt</code> file to your Git repository.</li> <li>Someone else (or you, in a new clone of the project) can recreate the environment by:<ul> <li>Creating a new virtual environment: <code>python3 -m venv .venv</code></li> <li>Activating it: <code>source .venv/bin/activate</code></li> <li>Installing dependencies: <code>pip install -r requirements.txt</code></li> </ul> </li> </ul> <p>You've now learned how to install a modern version of Python on Linux using Homebrew and how to effectively manage project dependencies using <code>venv</code>. Using virtual environments is a fundamental practice in Python development that keeps your projects organized and avoids dependency conflicts. Happy coding!</p>"},{"location":"setup/ssh/","title":"Using SSH Keys","text":"<p>Important</p> <ul> <li>Passphrase Requirement:<ul> <li>A passphrase must be used when creating SSH keys.<ul> <li>Using a passphrase increases the security when you are using SSH keys.</li> <li>Using a key without a passphrase can be risky.</li> <li>If someone obtains a key (from a backup tape, or a one-time vulnerability) that doesn't include a passphrase, the remote account can easily be compromised.</li> </ul> </li> </ul> </li> <li>Your SSH keys belongs to you, not your computer. This means if you get a new computer, copy your existing keypair(s) over to the new one.</li> <li>NEVER share your private key. Always make sure you are ever only using the key found in your <code>&lt;keyname&gt;.pub</code> file.</li> </ul>"},{"location":"setup/ssh/#generating-keys","title":"Generating keys","text":"<p>Create your PEM formatted key(s) then add it/them to your keychain and wherever you will need them.</p> <p>Run the following command to initiate the creation:</p> <pre><code>ssh-keygen -m PEM -t rsa -b 4096 -f ~/.ssh/id_rsa -C \"$(whoami)@$(uname -n)_$(date -I)\"\nssh-keygen -m PEM -t ed25519 -f ~/.ssh/id_ed25519 -C \"$(whoami)@$(uname -n)-$(date -I)\"\n</code></pre> <p>Now you need to enter a passphrase.</p> <pre><code># Enter passphrase (empty for no passphrase): [Type a passphrase]\n# Enter same passphrase again: [Type passphrase again]\n</code></pre> <p>Which should give output like this:</p> <pre><code>Your identification has been saved in /Users/username/.ssh/id_rsa.\nYour public key has been saved in /Users/username/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:vpEQnYp+5w9qbBznyb2r+Y9GwoHJBrExTOXgelISgLo username@computer_YYYY-MM-DD\nThe key's randomart image is:\n+---[ECDSA 521]---+\n|o..o*o.          |\n|.  oo* . .       |\n|. . +oooo        |\n|.  + .=o.        |\n| .o o.o.S.       |\n|E  +  .o+..      |\n|    .o.=*=       |\n|     .=++=o.     |\n|     o. ==*+.    |\n+----[SHA256]-----+\n</code></pre>"},{"location":"setup/ssh/#secure-file-permissions","title":"Secure File Permissions","text":"<p>Ensure your ssh directory and key files are properly secured:</p> <ul> <li>for the directory <pre><code>chmod 700 ~/.ssh\n</code></pre></li> <li>for private keys <pre><code>chmod 600 ~/.ssh/id_rsa\nchmod 600 ~/.ssh/id_ed25519\n</code></pre></li> <li>for public keys <pre><code>chmod 644 ~/.ssh/id_rsa.pub\nchmod 644 ~/.ssh/id_ed25519.pub\n</code></pre></li> </ul> <p>Note</p> <ul> <li><code>chmod 700</code> or <code>drwx------</code>: Grants all permissions only to the owner, and removes all other permissions to everyone else.</li> <li><code>chmod 600</code> or <code>-rw-------</code>: Grants read and write permissions to the owner, and removes all other permissions to everyone else.</li> <li><code>chmod 644</code> or <code>-rw-r--r--</code>: Grants read and write permissions to the owner, and read-only permissions to everyone else.</li> </ul>"},{"location":"setup/ssh/#adding-your-key-to-the-ssh-agent","title":"Adding your Key to the SSH Agent","text":"<ul> <li>Start the SSH Agent in the background <pre><code>eval \"$(ssh-agent -s)\"\n</code></pre></li> <li>Add the key: <pre><code>ssh-add ~/.ssh/id_rsa\nssh-add ~/.ssh/id_ed25519\n</code></pre></li> <li>Setup your ssh config: <pre><code>vi ~/.ssh/config\n</code></pre></li> <li>Paste in the following at the top: <pre><code>Host *\n    AddKeysToAgent yes\n    IdentityFile ~/.ssh/id_ed25519\n</code></pre></li> <li>List all managed keys: <pre><code>ssh-add -l\n</code></pre></li> </ul>"},{"location":"setup/ssh/#using-keychain","title":"Using Keychain","text":"<ul> <li>Install Keychain: <pre><code>sudo apt install keychain\n</code></pre></li> <li>Add this to your <code>.zshrc</code> file: <pre><code># Handling SSH Keys\n#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\nif [ -z \"$SSH_AUTH_SOCK\" ]; then\n    eval \"$(ssh-agent -s)\"\n    ssh-add -t 518400 ~/.ssh/id_ed25519\nfi\n</code></pre></li> </ul>"},{"location":"blog/archive/2025/","title":"May 2025","text":""},{"location":"blog/archive/2024/","title":"February 2024","text":""}]}